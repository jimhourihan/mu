//
//  Copyright (c) 2009, Jim Hourihan
//  All rights reserved.
// 
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//     * Redistributions of source code must retain the above
//       copyright notice, this list of conditions and the following
//       disclaimer.
//
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials
//       provided with the distribution.
//
//     * Neither the name of the software nor the names of its
//       contributors may be used to endorse or promote products
//       derived from this software without specific prior written
//       permission.
// 
//  THIS SOFTWARE IS PROVIDED BY Jim Hourihan ''AS IS'' AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL Jim Hourihan BE LIABLE FOR
//  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
//  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
//  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
//  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
//  DAMAGE.
//
#include "qtUtils.h"
#include "QTcpSocketType.h"
#include <QtGui/QtGui>
#include <QtSvg/QtSvg>
#include <QtNetwork/QtNetwork>
#include <QtWebKit/QtWebKit>
#include "QWidgetType.h"
#include "QActionType.h"
#include "QIconType.h"
#include <Mu/BaseFunctions.h>
#include <Mu/Thread.h>
#include <Mu/Alias.h>
#include <Mu/SymbolicConstant.h>
#include <Mu/ClassInstance.h>
#include <Mu/Function.h>
#include <Mu/MemberFunction.h>
#include <Mu/MemberVariable.h>
#include <Mu/Node.h>
#include <Mu/Exception.h>
#include <Mu/ParameterVariable.h>
#include <Mu/ReferenceType.h>
#include <Mu/Value.h>
#include <MuLang/MuLangContext.h>
#include <MuLang/StringType.h>

//
//  NOTE: this file was automatically generated by qt2mu.py
//

namespace Mu {
using namespace std;

//----------------------------------------------------------------------
//  INHERITABLE TYPE IMPLEMENTATION

// destructor
MuQt_QTcpSocket::~MuQt_QTcpSocket()
{
    if (_obj)
    {
        *_obj->data<Pointer>() = Pointer(0);
        _obj->releaseExternal();
    }
    _obj = 0;
    _env = 0;
    _baseType = 0;
}

MuQt_QTcpSocket::MuQt_QTcpSocket(Pointer muobj, const CallEnvironment* ce, QObject * parent) 
 : QTcpSocket(parent)
{
    _env = ce;
    _obj = reinterpret_cast<ClassInstance*>(muobj);
    _obj->retainExternal();
    MuLangContext* c = (MuLangContext*)_env->context();
    _baseType = c->findSymbolOfTypeByQualifiedName<QTcpSocketType>(c->internName("qt.QTcpSocket"));
}

bool MuQt_QTcpSocket::atEnd() const
{
    if (!_env) return QTcpSocket::atEnd();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[0];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QTcpSocket::atEnd();
    }
}

qint64 MuQt_QTcpSocket::bytesAvailable() const
{
    if (!_env) return QTcpSocket::bytesAvailable();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[1];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (int64)(rval._int64);
    }
    else
    {
        return QTcpSocket::bytesAvailable();
    }
}

qint64 MuQt_QTcpSocket::bytesToWrite() const
{
    if (!_env) return QTcpSocket::bytesToWrite();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[2];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (int64)(rval._int64);
    }
    else
    {
        return QTcpSocket::bytesToWrite();
    }
}

bool MuQt_QTcpSocket::canReadLine() const
{
    if (!_env) return QTcpSocket::canReadLine();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[3];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QTcpSocket::canReadLine();
    }
}

void MuQt_QTcpSocket::close() 
{
    if (!_env) { QTcpSocket::close(); return; }
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[4];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
    }
    else
    {
        QTcpSocket::close();
    }
}

bool MuQt_QTcpSocket::isSequential() const
{
    if (!_env) return QTcpSocket::isSequential();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[5];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QTcpSocket::isSequential();
    }
}

bool MuQt_QTcpSocket::waitForBytesWritten(int msecs) 
{
    if (!_env) return QTcpSocket::waitForBytesWritten(msecs);
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[6];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(2);
        args[0] = Value(Pointer(_obj));
        args[1] = Value(msecs);
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QTcpSocket::waitForBytesWritten(msecs);
    }
}

bool MuQt_QTcpSocket::waitForReadyRead(int msecs) 
{
    if (!_env) return QTcpSocket::waitForReadyRead(msecs);
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[7];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(2);
        args[0] = Value(Pointer(_obj));
        args[1] = Value(msecs);
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QTcpSocket::waitForReadyRead(msecs);
    }
}



//----------------------------------------------------------------------
//  Mu Type CONSTRUCTORS

QTcpSocketType::QTcpSocketType(Context* c, const char* name, Class* super, Class* super2)
: Class(c, name, vectorOf2(super, super2))
{
}

QTcpSocketType::~QTcpSocketType()
{
}

//----------------------------------------------------------------------
//  PRE-COMPILED FUNCTIONS

static Pointer
QTcpSocket_QTcpSocket_QObject(Thread& NODE_THREAD, Pointer obj)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    ClassInstance* widget = reinterpret_cast<ClassInstance*>(obj);

    if (!widget)
    {
        return 0;
    }
    else if (QTcpSocket* w = object<QTcpSocket>(widget))
    {
        QTcpSocketType* type = 
            c->findSymbolOfTypeByQualifiedName<QTcpSocketType>(c->internName("qt.QTcpSocket"), false);
        ClassInstance* o = ClassInstance::allocate(type);
        setobject(o, w);
        return o;
    }
    else
    {
        throw BadCastException();
    }
}

static NODE_IMPLEMENTATION(castFromObject, Pointer)
{
    NODE_RETURN( QTcpSocket_QTcpSocket_QObject(NODE_THREAD, NODE_ARG(0, Pointer)) );
}

Pointer qt_QTcpSocket_QTcpSocket_QTcpSocket_QTcpSocket_QObject(Mu::Thread& NODE_THREAD, Pointer param_this, Pointer param_parent)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QObject * arg1 = object<QObject>(param_parent);
    setobject(param_this, new MuQt_QTcpSocket(param_this, NODE_THREAD.process()->callEnv(), arg1));
    return param_this;
}

bool qt_QTcpSocket_atEnd_bool_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::atEnd() : arg0->atEnd();
}

int64 qt_QTcpSocket_bytesAvailable_int64_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::bytesAvailable() : arg0->bytesAvailable();
}

int64 qt_QTcpSocket_bytesToWrite_int64_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::bytesToWrite() : arg0->bytesToWrite();
}

bool qt_QTcpSocket_canReadLine_bool_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::canReadLine() : arg0->canReadLine();
}

void qt_QTcpSocket_close_void_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    if (isMuQtObject(arg0)) arg0->QTcpSocket::close();
    else arg0->close();
}

bool qt_QTcpSocket_isSequential_bool_QTcpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::isSequential() : arg0->isSequential();
}

bool qt_QTcpSocket_waitForBytesWritten_bool_QTcpSocket_int(Mu::Thread& NODE_THREAD, Pointer param_this, int param_msecs)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    int arg1 = (int)(param_msecs);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::waitForBytesWritten(arg1) : arg0->waitForBytesWritten(arg1);
}

bool qt_QTcpSocket_waitForReadyRead_bool_QTcpSocket_int(Mu::Thread& NODE_THREAD, Pointer param_this, int param_msecs)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QTcpSocket* arg0 = object<QTcpSocket>(param_this);
    int arg1 = (int)(param_msecs);
    return isMuQtObject(arg0) ? arg0->QTcpSocket::waitForReadyRead(arg1) : arg0->waitForReadyRead(arg1);
}


static NODE_IMPLEMENTATION(_n_QTcpSocket0, Pointer)
{
    NODE_RETURN(qt_QTcpSocket_QTcpSocket_QTcpSocket_QTcpSocket_QObject(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer)));
}

static NODE_IMPLEMENTATION(_n_atEnd0, bool)
{
    NODE_RETURN(qt_QTcpSocket_atEnd_bool_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_bytesAvailable0, int64)
{
    NODE_RETURN(qt_QTcpSocket_bytesAvailable_int64_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_bytesToWrite0, int64)
{
    NODE_RETURN(qt_QTcpSocket_bytesToWrite_int64_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_canReadLine0, bool)
{
    NODE_RETURN(qt_QTcpSocket_canReadLine_bool_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_close0, void)
{
    qt_QTcpSocket_close_void_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer));
}

static NODE_IMPLEMENTATION(_n_isSequential0, bool)
{
    NODE_RETURN(qt_QTcpSocket_isSequential_bool_QTcpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_waitForBytesWritten0, bool)
{
    NODE_RETURN(qt_QTcpSocket_waitForBytesWritten_bool_QTcpSocket_int(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, int)));
}

static NODE_IMPLEMENTATION(_n_waitForReadyRead0, bool)
{
    NODE_RETURN(qt_QTcpSocket_waitForReadyRead_bool_QTcpSocket_int(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, int)));
}



void
QTcpSocketType::load()
{
    USING_MU_FUNCTION_SYMBOLS;
    MuLangContext* c = static_cast<MuLangContext*>(context());
    Module* global = globalModule();
    
    const string typeName        = name();
    const string refTypeName     = typeName + "&";
    const string fullTypeName    = fullyQualifiedName();
    const string fullRefTypeName = fullTypeName + "&";
    const char*  tn              = typeName.c_str();
    const char*  ftn             = fullTypeName.c_str();
    const char*  rtn             = refTypeName.c_str();
    const char*  frtn            = fullRefTypeName.c_str();

    scope()->addSymbols(new ReferenceType(c, rtn, this),

                        new Function(c, tn, BaseFunctions::dereference, Cast,
                                     Return, ftn,
                                     Args, frtn, End),

                        EndArguments);
    
    addSymbols(new Function(c, "__allocate", BaseFunctions::classAllocate, None,
                            Return, ftn,
                            End),


               new Function(c, tn, castFromObject, Cast,
                            Compiled, QTcpSocket_QTcpSocket_QObject,
                            Return, ftn,
                            Parameters,
                            new Param(c, "object", "qt.QObject"),
                            End),

               EndArguments );

addSymbols(
    // enums
    // member functions
    new Function(c, "QTcpSocket", _n_QTcpSocket0, None, Compiled, qt_QTcpSocket_QTcpSocket_QTcpSocket_QTcpSocket_QObject, Return, "qt.QTcpSocket", Parameters, new Param(c, "this", "qt.QTcpSocket"), new Param(c, "parent", "qt.QObject"), End),
    _func[0] = new MemberFunction(c, "atEnd", _n_atEnd0, None, Compiled, qt_QTcpSocket_atEnd_bool_QTcpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[1] = new MemberFunction(c, "bytesAvailable", _n_bytesAvailable0, None, Compiled, qt_QTcpSocket_bytesAvailable_int64_QTcpSocket, Return, "int64", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[2] = new MemberFunction(c, "bytesToWrite", _n_bytesToWrite0, None, Compiled, qt_QTcpSocket_bytesToWrite_int64_QTcpSocket, Return, "int64", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[3] = new MemberFunction(c, "canReadLine", _n_canReadLine0, None, Compiled, qt_QTcpSocket_canReadLine_bool_QTcpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[4] = new MemberFunction(c, "close", _n_close0, None, Compiled, qt_QTcpSocket_close_void_QTcpSocket, Return, "void", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[5] = new MemberFunction(c, "isSequential", _n_isSequential0, None, Compiled, qt_QTcpSocket_isSequential_bool_QTcpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QTcpSocket"), End),
    _func[6] = new MemberFunction(c, "waitForBytesWritten", _n_waitForBytesWritten0, None, Compiled, qt_QTcpSocket_waitForBytesWritten_bool_QTcpSocket_int, Return, "bool", Parameters, new Param(c, "this", "qt.QTcpSocket"), new Param(c, "msecs", "int"), End),
    _func[7] = new MemberFunction(c, "waitForReadyRead", _n_waitForReadyRead0, None, Compiled, qt_QTcpSocket_waitForReadyRead_bool_QTcpSocket_int, Return, "bool", Parameters, new Param(c, "this", "qt.QTcpSocket"), new Param(c, "msecs", "int"), End),
    // MISSING: readData (int64; QTcpSocket this, "char *" data, int64 maxSize) // protected
    // MISSING: readLineData (int64; QTcpSocket this, "char *" data, int64 maxlen) // protected
    // MISSING: writeData (int64; QTcpSocket this, "const char *" data, int64 size) // protected
    // static functions
    EndArguments);
globalScope()->addSymbols(
    EndArguments);
scope()->addSymbols(
    EndArguments);


    const char** propExclusions = 0;

    populate(this, QTcpSocket::staticMetaObject, propExclusions);
}

} // Mu
