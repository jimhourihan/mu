//
//  Copyright (c) 2009, Jim Hourihan
//  All rights reserved.
// 
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//     * Redistributions of source code must retain the above
//       copyright notice, this list of conditions and the following
//       disclaimer.
//
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials
//       provided with the distribution.
//
//     * Neither the name of the software nor the names of its
//       contributors may be used to endorse or promote products
//       derived from this software without specific prior written
//       permission.
// 
//  THIS SOFTWARE IS PROVIDED BY Jim Hourihan ''AS IS'' AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL Jim Hourihan BE LIABLE FOR
//  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
//  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
//  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
//  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
//  DAMAGE.
//
#include "qtUtils.h"
#include "QUdpSocketType.h"
#include <QtGui/QtGui>
#include <QtSvg/QtSvg>
#include <QtNetwork/QtNetwork>
#include <QtWebKit/QtWebKit>
#include "QWidgetType.h"
#include "QActionType.h"
#include "QIconType.h"
#include <Mu/BaseFunctions.h>
#include <Mu/Thread.h>
#include <Mu/Alias.h>
#include <Mu/SymbolicConstant.h>
#include <Mu/ClassInstance.h>
#include <Mu/Function.h>
#include <Mu/MemberFunction.h>
#include <Mu/MemberVariable.h>
#include <Mu/Node.h>
#include <Mu/Exception.h>
#include <Mu/ParameterVariable.h>
#include <Mu/ReferenceType.h>
#include <Mu/Value.h>
#include <MuLang/MuLangContext.h>
#include <MuLang/StringType.h>
#include "QHostAddressType.h"

//
//  NOTE: this file was automatically generated by qt2mu.py
//

namespace Mu {
using namespace std;

//----------------------------------------------------------------------
//  INHERITABLE TYPE IMPLEMENTATION

// destructor
MuQt_QUdpSocket::~MuQt_QUdpSocket()
{
    if (_obj)
    {
        *_obj->data<Pointer>() = Pointer(0);
        _obj->releaseExternal();
    }
    _obj = 0;
    _env = 0;
    _baseType = 0;
}

MuQt_QUdpSocket::MuQt_QUdpSocket(Pointer muobj, const CallEnvironment* ce, QObject * parent) 
 : QUdpSocket(parent)
{
    _env = ce;
    _obj = reinterpret_cast<ClassInstance*>(muobj);
    _obj->retainExternal();
    MuLangContext* c = (MuLangContext*)_env->context();
    _baseType = c->findSymbolOfTypeByQualifiedName<QUdpSocketType>(c->internName("qt.QUdpSocket"));
}

bool MuQt_QUdpSocket::atEnd() const
{
    if (!_env) return QUdpSocket::atEnd();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[0];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QUdpSocket::atEnd();
    }
}

qint64 MuQt_QUdpSocket::bytesAvailable() const
{
    if (!_env) return QUdpSocket::bytesAvailable();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[1];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (int64)(rval._int64);
    }
    else
    {
        return QUdpSocket::bytesAvailable();
    }
}

qint64 MuQt_QUdpSocket::bytesToWrite() const
{
    if (!_env) return QUdpSocket::bytesToWrite();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[2];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (int64)(rval._int64);
    }
    else
    {
        return QUdpSocket::bytesToWrite();
    }
}

bool MuQt_QUdpSocket::canReadLine() const
{
    if (!_env) return QUdpSocket::canReadLine();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[3];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QUdpSocket::canReadLine();
    }
}

void MuQt_QUdpSocket::close() 
{
    if (!_env) { QUdpSocket::close(); return; }
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[4];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
    }
    else
    {
        QUdpSocket::close();
    }
}

bool MuQt_QUdpSocket::isSequential() const
{
    if (!_env) return QUdpSocket::isSequential();
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[5];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(1);
        args[0] = Value(Pointer(_obj));
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QUdpSocket::isSequential();
    }
}

bool MuQt_QUdpSocket::waitForBytesWritten(int msecs) 
{
    if (!_env) return QUdpSocket::waitForBytesWritten(msecs);
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[6];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(2);
        args[0] = Value(Pointer(_obj));
        args[1] = Value(msecs);
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QUdpSocket::waitForBytesWritten(msecs);
    }
}

bool MuQt_QUdpSocket::waitForReadyRead(int msecs) 
{
    if (!_env) return QUdpSocket::waitForReadyRead(msecs);
    MuLangContext* c = (MuLangContext*)_env->context();
    const MemberFunction* F0 = _baseType->_func[7];
    const MemberFunction* F = _obj->classType()->dynamicLookup(F0);
    if (F != F0) 
    {
        Function::ArgumentVector args(2);
        args[0] = Value(Pointer(_obj));
        args[1] = Value(msecs);
        Value rval = _env->call(F, args);
        return (bool)(rval._bool);
    }
    else
    {
        return QUdpSocket::waitForReadyRead(msecs);
    }
}



//----------------------------------------------------------------------
//  Mu Type CONSTRUCTORS

QUdpSocketType::QUdpSocketType(Context* c, const char* name, Class* super, Class* super2)
: Class(c, name, vectorOf2(super, super2))
{
}

QUdpSocketType::~QUdpSocketType()
{
}

//----------------------------------------------------------------------
//  PRE-COMPILED FUNCTIONS

static Pointer
QUdpSocket_QUdpSocket_QObject(Thread& NODE_THREAD, Pointer obj)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    ClassInstance* widget = reinterpret_cast<ClassInstance*>(obj);

    if (!widget)
    {
        return 0;
    }
    else if (QUdpSocket* w = object<QUdpSocket>(widget))
    {
        QUdpSocketType* type = 
            c->findSymbolOfTypeByQualifiedName<QUdpSocketType>(c->internName("qt.QUdpSocket"), false);
        ClassInstance* o = ClassInstance::allocate(type);
        setobject(o, w);
        return o;
    }
    else
    {
        throw BadCastException();
    }
}

static NODE_IMPLEMENTATION(castFromObject, Pointer)
{
    NODE_RETURN( QUdpSocket_QUdpSocket_QObject(NODE_THREAD, NODE_ARG(0, Pointer)) );
}

Pointer qt_QUdpSocket_QUdpSocket_QUdpSocket_QUdpSocket_QObject(Mu::Thread& NODE_THREAD, Pointer param_this, Pointer param_parent)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QObject * arg1 = object<QObject>(param_parent);
    setobject(param_this, new MuQt_QUdpSocket(param_this, NODE_THREAD.process()->callEnv(), arg1));
    return param_this;
}

bool qt_QUdpSocket_hasPendingDatagrams_bool_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return arg0->hasPendingDatagrams();
}

bool qt_QUdpSocket_joinMulticastGroup_bool_QUdpSocket_QHostAddress(Mu::Thread& NODE_THREAD, Pointer param_this, Pointer param_groupAddress)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    const QHostAddress  arg1 = getqtype<QHostAddressType>(param_groupAddress);
    return arg0->joinMulticastGroup(arg1);
}

bool qt_QUdpSocket_leaveMulticastGroup_bool_QUdpSocket_QHostAddress(Mu::Thread& NODE_THREAD, Pointer param_this, Pointer param_groupAddress)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    const QHostAddress  arg1 = getqtype<QHostAddressType>(param_groupAddress);
    return arg0->leaveMulticastGroup(arg1);
}

int64 qt_QUdpSocket_pendingDatagramSize_int64_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return arg0->pendingDatagramSize();
}

bool qt_QUdpSocket_atEnd_bool_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::atEnd() : arg0->atEnd();
}

int64 qt_QUdpSocket_bytesAvailable_int64_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::bytesAvailable() : arg0->bytesAvailable();
}

int64 qt_QUdpSocket_bytesToWrite_int64_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::bytesToWrite() : arg0->bytesToWrite();
}

bool qt_QUdpSocket_canReadLine_bool_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::canReadLine() : arg0->canReadLine();
}

void qt_QUdpSocket_close_void_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    if (isMuQtObject(arg0)) arg0->QUdpSocket::close();
    else arg0->close();
}

bool qt_QUdpSocket_isSequential_bool_QUdpSocket(Mu::Thread& NODE_THREAD, Pointer param_this)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::isSequential() : arg0->isSequential();
}

bool qt_QUdpSocket_waitForBytesWritten_bool_QUdpSocket_int(Mu::Thread& NODE_THREAD, Pointer param_this, int param_msecs)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    int arg1 = (int)(param_msecs);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::waitForBytesWritten(arg1) : arg0->waitForBytesWritten(arg1);
}

bool qt_QUdpSocket_waitForReadyRead_bool_QUdpSocket_int(Mu::Thread& NODE_THREAD, Pointer param_this, int param_msecs)
{
    MuLangContext* c = static_cast<MuLangContext*>(NODE_THREAD.context());
    QUdpSocket* arg0 = object<QUdpSocket>(param_this);
    int arg1 = (int)(param_msecs);
    return isMuQtObject(arg0) ? arg0->QUdpSocket::waitForReadyRead(arg1) : arg0->waitForReadyRead(arg1);
}


static NODE_IMPLEMENTATION(_n_QUdpSocket0, Pointer)
{
    NODE_RETURN(qt_QUdpSocket_QUdpSocket_QUdpSocket_QUdpSocket_QObject(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer)));
}

static NODE_IMPLEMENTATION(_n_hasPendingDatagrams0, bool)
{
    NODE_RETURN(qt_QUdpSocket_hasPendingDatagrams_bool_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_joinMulticastGroup0, bool)
{
    NODE_RETURN(qt_QUdpSocket_joinMulticastGroup_bool_QUdpSocket_QHostAddress(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer)));
}

static NODE_IMPLEMENTATION(_n_leaveMulticastGroup0, bool)
{
    NODE_RETURN(qt_QUdpSocket_leaveMulticastGroup_bool_QUdpSocket_QHostAddress(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, Pointer)));
}

static NODE_IMPLEMENTATION(_n_pendingDatagramSize0, int64)
{
    NODE_RETURN(qt_QUdpSocket_pendingDatagramSize_int64_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_atEnd0, bool)
{
    NODE_RETURN(qt_QUdpSocket_atEnd_bool_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_bytesAvailable0, int64)
{
    NODE_RETURN(qt_QUdpSocket_bytesAvailable_int64_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_bytesToWrite0, int64)
{
    NODE_RETURN(qt_QUdpSocket_bytesToWrite_int64_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_canReadLine0, bool)
{
    NODE_RETURN(qt_QUdpSocket_canReadLine_bool_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_close0, void)
{
    qt_QUdpSocket_close_void_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer));
}

static NODE_IMPLEMENTATION(_n_isSequential0, bool)
{
    NODE_RETURN(qt_QUdpSocket_isSequential_bool_QUdpSocket(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer)));
}

static NODE_IMPLEMENTATION(_n_waitForBytesWritten0, bool)
{
    NODE_RETURN(qt_QUdpSocket_waitForBytesWritten_bool_QUdpSocket_int(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, int)));
}

static NODE_IMPLEMENTATION(_n_waitForReadyRead0, bool)
{
    NODE_RETURN(qt_QUdpSocket_waitForReadyRead_bool_QUdpSocket_int(NODE_THREAD, NONNIL_NODE_ARG(0, Pointer), NODE_ARG(1, int)));
}



void
QUdpSocketType::load()
{
    USING_MU_FUNCTION_SYMBOLS;
    MuLangContext* c = static_cast<MuLangContext*>(context());
    Module* global = globalModule();
    
    const string typeName        = name();
    const string refTypeName     = typeName + "&";
    const string fullTypeName    = fullyQualifiedName();
    const string fullRefTypeName = fullTypeName + "&";
    const char*  tn              = typeName.c_str();
    const char*  ftn             = fullTypeName.c_str();
    const char*  rtn             = refTypeName.c_str();
    const char*  frtn            = fullRefTypeName.c_str();

    scope()->addSymbols(new ReferenceType(c, rtn, this),

                        new Function(c, tn, BaseFunctions::dereference, Cast,
                                     Return, ftn,
                                     Args, frtn, End),

                        EndArguments);
    
    addSymbols(new Function(c, "__allocate", BaseFunctions::classAllocate, None,
                            Return, ftn,
                            End),


               new Function(c, tn, castFromObject, Cast,
                            Compiled, QUdpSocket_QUdpSocket_QObject,
                            Return, ftn,
                            Parameters,
                            new Param(c, "object", "qt.QObject"),
                            End),

               EndArguments );

addSymbols(
    // enums
    // member functions
    new Function(c, "QUdpSocket", _n_QUdpSocket0, None, Compiled, qt_QUdpSocket_QUdpSocket_QUdpSocket_QUdpSocket_QObject, Return, "qt.QUdpSocket", Parameters, new Param(c, "this", "qt.QUdpSocket"), new Param(c, "parent", "qt.QObject"), End),
    // MISSING: bind (bool; QUdpSocket this, QHostAddress address, "quint16" port)
    // MISSING: bind (bool; QUdpSocket this, QHostAddress address, "quint16" port, flags QUdpSocket::BindMode mode)
    // MISSING: bind (bool; QUdpSocket this, "quint16" port)
    // MISSING: bind (bool; QUdpSocket this, "quint16" port, flags QUdpSocket::BindMode mode)
    new Function(c, "hasPendingDatagrams", _n_hasPendingDatagrams0, None, Compiled, qt_QUdpSocket_hasPendingDatagrams_bool_QUdpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    new Function(c, "joinMulticastGroup", _n_joinMulticastGroup0, None, Compiled, qt_QUdpSocket_joinMulticastGroup_bool_QUdpSocket_QHostAddress, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), new Param(c, "groupAddress", "qt.QHostAddress"), End),
    // MISSING: joinMulticastGroup (bool; QUdpSocket this, QHostAddress groupAddress, "const QNetworkInterface &" iface)
    new Function(c, "leaveMulticastGroup", _n_leaveMulticastGroup0, None, Compiled, qt_QUdpSocket_leaveMulticastGroup_bool_QUdpSocket_QHostAddress, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), new Param(c, "groupAddress", "qt.QHostAddress"), End),
    // MISSING: leaveMulticastGroup (bool; QUdpSocket this, QHostAddress groupAddress, "const QNetworkInterface &" iface)
    // MISSING: multicastInterface ("QNetworkInterface"; QUdpSocket this)
    new Function(c, "pendingDatagramSize", _n_pendingDatagramSize0, None, Compiled, qt_QUdpSocket_pendingDatagramSize_int64_QUdpSocket, Return, "int64", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    // MISSING: readDatagram (int64; QUdpSocket this, "char *" data, int64 maxSize, QHostAddress address, "quint16 *" port)
    // MISSING: setMulticastInterface (void; QUdpSocket this, "const QNetworkInterface &" iface)
    // MISSING: writeDatagram (int64; QUdpSocket this, "const char *" data, int64 size, QHostAddress address, "quint16" port)
    // MISSING: writeDatagram (int64; QUdpSocket this, QByteArray datagram, QHostAddress host, "quint16" port)
    _func[0] = new MemberFunction(c, "atEnd", _n_atEnd0, None, Compiled, qt_QUdpSocket_atEnd_bool_QUdpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[1] = new MemberFunction(c, "bytesAvailable", _n_bytesAvailable0, None, Compiled, qt_QUdpSocket_bytesAvailable_int64_QUdpSocket, Return, "int64", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[2] = new MemberFunction(c, "bytesToWrite", _n_bytesToWrite0, None, Compiled, qt_QUdpSocket_bytesToWrite_int64_QUdpSocket, Return, "int64", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[3] = new MemberFunction(c, "canReadLine", _n_canReadLine0, None, Compiled, qt_QUdpSocket_canReadLine_bool_QUdpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[4] = new MemberFunction(c, "close", _n_close0, None, Compiled, qt_QUdpSocket_close_void_QUdpSocket, Return, "void", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[5] = new MemberFunction(c, "isSequential", _n_isSequential0, None, Compiled, qt_QUdpSocket_isSequential_bool_QUdpSocket, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), End),
    _func[6] = new MemberFunction(c, "waitForBytesWritten", _n_waitForBytesWritten0, None, Compiled, qt_QUdpSocket_waitForBytesWritten_bool_QUdpSocket_int, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), new Param(c, "msecs", "int"), End),
    _func[7] = new MemberFunction(c, "waitForReadyRead", _n_waitForReadyRead0, None, Compiled, qt_QUdpSocket_waitForReadyRead_bool_QUdpSocket_int, Return, "bool", Parameters, new Param(c, "this", "qt.QUdpSocket"), new Param(c, "msecs", "int"), End),
    // MISSING: readData (int64; QUdpSocket this, "char *" data, int64 maxSize) // protected
    // MISSING: readLineData (int64; QUdpSocket this, "char *" data, int64 maxlen) // protected
    // MISSING: writeData (int64; QUdpSocket this, "const char *" data, int64 size) // protected
    // static functions
    EndArguments);
globalScope()->addSymbols(
    EndArguments);
scope()->addSymbols(
    EndArguments);


    const char** propExclusions = 0;

    populate(this, QUdpSocket::staticMetaObject, propExclusions);
}

} // Mu
