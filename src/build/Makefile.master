#  -*- mode: makefile -*-
# 
#  Copyright (c) 2001, Tweak Films
#  Copyright (c) 2008, Tweak Software
# 
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#     * Redistributions of source code must retain the above
#       copyright notice, this list of conditions and the following
#       disclaimer.
#
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
#     * Neither the name of the Tweak Software nor the names of its
#       contributors may be used to endorse or promote products
#       derived from this software without specific prior written
#       permission.
# 
#  THIS SOFTWARE IS PROVIDED BY Tweak Software ''AS IS'' AND ANY EXPRESS
#  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL Tweak Software BE LIABLE FOR
#  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
#  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
#  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
#  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
#  DAMAGE.
#
# 
#  This is the master Makefile. See $(MAKE_ROOT)/DESCRIPTION for
#  details on implementation and usage.
#

#
# The default filename of the current project Makefile
#

PROJECT_MAKEFILE ?= Makefile

#
#  If the build root has not been inited
#  default the BUILD_TYPE to RELEASE if undefined
#
ifeq ($(wildcard $(build_makefile)),)
BUILD_TYPE       ?= RELEASE
endif

#----------------------------------------------------------------------
#
#   Make "functions"
#

map = $(foreach a,$(2),$(call $(1),$(a)))

vargroup = $($(1)) \
	   $($(addprefix $(1)_,$(PLATFORM))) \
	   $($(addprefix $(1)_,$(COMPILER))) \
	   $($(addprefix $(1)_,$(ARCH))) \
	   $($(addprefix $(1)_,$(PLATFORM)_$(ARCH)))  \
	   $($(addprefix $(1)_,$(PLATFORM)_$(BUILD_TYPE))) \
	   $($(addprefix $(1)_,$(PLATFORM)_$(ARCH)_$(BUILD_TYPE))) 

vargroupnr = $($(addprefix $(1)_,$(PLATFORM))) \
	     $($(addprefix $(1)_,$(COMPILER))) \
	     $($(addprefix $(1)_,$(ARCH))) \
	     $($(addprefix $(1)_,$(PLATFORM)_$(ARCH))) \
	     $($(addprefix $(1)_,$(PLATFORM)_$(BUILD_TYPE))) \
	     $($(addprefix $(1)_,$(PLATFORM)_$(ARCH)_$(BUILD_TYPE))) 


#  
# Windows cygwin path handling functions.
# Extract the cygdrive letter in SRC_ROOT if it exists
#
SRC_ROOT_DRIVE = $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(SRC_ROOT))))
BUILD_ROOT_DRIVE = $(firstword $(subst /, ,$(patsubst /cygdrive/%,%,$(BUILD_ROOT))))
MSVC_DRIVE ?= c

cygdriveconvert = $(subst /cygdrive/$(1),$(1):,$(2))
ifeq ($(MSVCDRIVE),$(SRC_ROOT_DRIVE))
  ifeq ($(MSVCDRIVE),$(BUILD_ROOT_DRIVE))
    cygpathconvert = $(call cygdriveconvert,$(MSVC_DRIVE),$(1))
  else
    cygpathconvert = $(call cygdriveconvert,$(MSVC_DRIVE),$(call cygdriveconvert,$(BUILD_ROOT_DRIVE),$(1)))
  endif
else
  ifeq ($(SRC_ROOT_DRIVE),$(BUILD_ROOT_DRIVE))
    cygpathconvert = $(call cygdriveconvert,$(MSVC_DRIVE),$(call cygdriveconvert,$(SRC_ROOT_DRIVE),$(1)))
  else
    cygpathconvert = $(call cygdriveconvert,$(MSVC_DRIVE),$(call cygdriveconvert,$(SRC_ROOT_DRIVE),$(call cygdriveconvert,$(BUILD_ROOT_DRIVE),$(1))))
  endif
endif


tolower = $(shell echo $(1) | tr '[:upper:]' '[:lower:]')
toupper = $(shell echo $(1) | tr '[:lower:]' '[:upper:]')

ifeq ($(filter k -k,$(MAKEFLAGS)),)
EXIT_ERR := exit $$err
else
EXIT_ERR := echo "Ignored error because of '-k' flag."
endif

errorhandler =  $(1); err=$$?; if [ $$err -ne 0 ]; then       \
                echo ""; echo "*** Error: encountered executing '$(1)'"; echo "";    \
                $(EXIT_ERR); \
                fi;                      

#----------------------------------------------------------------------

BOOST_LIB_PATTERN ?= boost_%
boostname = $(patsubst boost_%,$(BOOST_LIB_PATTERN),$($(1)))

#----------------------------------------------------------------------

ifneq ($(SHOW_OUTPUT),TRUE)
SHOWCMD := @
endif

CXXSUFFIX   ?= .cpp
MXXSUFFIX   ?= .mm
MSUFFIX	    ?= .m
CSUFFIX	    ?= .c
HSUFFIX	    ?= .h
HPPSUFFIX   ?= .hpp
LSUFFIX	    ?= .l
SSUFFIX     ?= .s
YSUFFIX	    ?= .y
ARSUFFIX    ?= .a
OBJSUFFIX   ?= .o
SOSUFFIX    ?= .so
BINSUFFIX   ?=
YASMSUFFIX  ?= .asm
MASMSUFFIX  ?= .masm
LIBPREFIX   ?= lib
UIPREFIX    ?= ui_
UISUFFIX    ?= .ui
MOCPREFIX   ?= moc_
QRCPREFIX   ?= qrc_
QRCSUFFIX   ?= .qrc
LOAD_TYPE   ?= LOADALL

#BUILD_TYPE  ?= DEBUG

#----------------------------------------------------------------------
#
#	Do sanity checks on variables
#

ifndef SRC_ROOT
$(error "SRC_ROOT must be set")
endif

ifndef BUILD_ROOT
$(error "BUILD_ROOT must be set")
endif

ifndef PROJECT
ifndef PACKAGE
$(error "PROJECT or PACKAGE must be set")
endif
endif

ifdef MAYA_PROJECT
ifndef MAYA_LOCATION
$(error "MAYA_LOCATION must be set for MAYA_PROJECTs")
endif
endif

MAKE_ROOT       ?= $(SRC_ROOT)/build
PLUGIN_DIR	?= plugins
ENTROPYHOME	?= /usr/local/exluna/Entropy
SHAREFLAGS	?= 
DYNAMIC		?= $(SHARED)
PLUGINSUFFIX    ?= $(SOSUFFIX)
TMPDIR          ?= /tmp
SCRIPTS_DIR     ?= scripts
UI_DIR          ?= ui
NEVERDYNAMIC    ?=
POST_PROCESS    ?= echo

MAJOR_VERSION   ?= 99
MINOR_VERSION   ?= 99
REVISION_NUMBER ?= 99
RELEASE_DESCRIPTION ?= "Development"

EXTRA_APPLICATIONS ?= 
SRCPREFIX ?=

CC      ?= gcc
CXX     ?= g++
MXX     ?= gcc
MCC     ?= gcc
YASM    ?= yasm
MASM    ?= ml64

MKDIR   ?= mkdir -p
RM	?= rm -f
RRM	?= rm -rf
PAGER	?= less
ECHO	?= echo
MV	?= mv
AR	?= ar r

RC      ?= rc$(BINSUFFIX)

PCC     ?= $(CC) -E

CXX_MD  ?= $(CXX)
CC_MD   ?= $(CC)
MXX_MD  ?= $(MXX)
MCC_MD  ?= $(MCC)
CXX_LD  ?= $(CXX)
MAYA_LD ?= $(CXX_LD)

QUOTEFILE ?= $(SRC_ROOT)/build/quoteFile

ARCHFLAGS ?= 

INCLUDE_SWITCH ?= -I
LOADPATH_SWITCH ?= -L
FWORKSPATH_SWITCH ?= -F

#----------------------------------------------------------------------
#
#   Platform specific TYPE variable
#

ifdef TYPE_$(PLATFORM)
TYPE := $(TYPE_$(PLATFORM))
endif

#----------------------------------------------------------------------
#
#	Derived
#

platform_makefile   = $(MAKE_ROOT)/targets/Makefile.$(PLATFORM).$(ARCH).$(COMPILER)
target_makefile     = $(platform_makefile).$(BUILD_TYPE)
build_makefile	    = $(BUILD_ROOT)/build/Makefile.build
build_makefile_qt   = $(MAKE_ROOT)/Makefile.build.qt
makefile_uses       = $(MAKE_ROOT)/Makefile.uses
makefile_external_deplibs_rules = $(MAKE_ROOT)/Makefile.external_deplibs_rules
src_dir             = $(shell /bin/pwd)
bin_dir		    = $(BUILD_ROOT)/bin
lib_dir		    = $(BUILD_ROOT)/lib
frameworks_dir	    = $(lib_dir)
include_dir	    = $(BUILD_ROOT)/include
header_dir	    = $(include_dir)/$(PROJECT)
metasrc_root_dir    = $(BUILD_ROOT)/metasrc
metasrc_dir         = $(metasrc_root_dir)/$(PROJECT)
plugin_dir	    = $(BUILD_ROOT)/$(PLUGIN_DIR)
scripts_dir         = $(BUILD_ROOT)/$(SCRIPTS_DIR)
aux_dir	            = $(BUILD_ROOT)/$(AUX_DIR)
ui_dir              = $(BUILD_ROOT)/$(UI_DIR)
obj_dir		    = $(BUILD_ROOT)/objects/$(OBJ_BASE_DIR)$(PROJECT)
makefile_d	    = $(obj_dir)/Makefile.d
build_build_dir	    = $(BUILD_ROOT)/build
etc_dir             = $(BUILD_ROOT)/etc
build_dirs	    = $(plugin_dir) $(include_dir) $(lib_dir) \
		      $(build_build_dir) $(etc_dir) $(html_dir) \
		      $(scripts_dir) $(pdf_dir) $(metasrc_root_dir)
rvpkg_dir	    = $(BUILD_ROOT)/rvpkg
info_dir	    = $(BUILD_ROOT)/info
pdf_dir		    = $(BUILD_ROOT)/doc
html_dir	    = $(BUILD_ROOT)/html
html_temp_dir	    = $(BUILD_ROOT)/html/temp
interdepend	    = $(MAKE_ROOT)/makeInterdepend
makedeplibs	    = $(MAKE_ROOT)/makeDeplibs
makemodules	    = $(MAKE_ROOT)/makeModules
makeqmake	    = $(MAKE_ROOT)/makeQMakeProject
archflags	    = $(ARCHFLAGS)
deplibs		    = $(DEPLIBS) $(call vargroup,EXTERNAL_DEPLIBS)


ifeq ($(TYPE),TEST)
obj_dir := $(obj_dir)/test
endif

#
#   make NO_MODULES=1
#   (faster compile/line)
#
ifeq ($(NO_MODULES),1)
override POST_PROCESS	= echo
override MODULES	=
override RVPACKAGES	= 
override RVPACKAGES2	= 
endif

#
# These Darwin / OSX specific 
# for types NSAPPLICATION, NSFRAMEWORK, DISTRIBUTION_DMG, DISTRIBUTION_PKG,
# DISTRIBUTION_CODESIGN_PKG
#
bundle_dir	    = $(BUILD_ROOT)/$(bundle_root)/$(bundle_name)
contents_dir	    = $(bundle_dir)/Contents
contents_lib_dir    = $(contents_dir)/lib
osbin_dir	    = $(contents_dir)/MacOS
resource_dir	    = $(contents_dir)/Resources
info_plist	    = $(contents_dir)/Info.plist
frameworks_dir	    = $(contents_dir)/Frameworks


#----------------------------------------------------------------------
#
#   Rule Bodies: these can be overriden for non-gcc-like compilers
#

CXX_OBJ_RULE     ?= $(CXX) $(archflags) $(CXXFLAGS) -c $(SRCPREFIX)$< -o $@
CC_OBJ_RULE      ?= $(CC) $(archflags) $(CFLAGS) -c $(SRCPREFIX)$< -o $@
S_OBJ_RULE       ?= $(CC) $(archflags) $(SFLAGS) -c $(SRCPREFIX)$< -o $@
MCC_OBJ_RULE     ?= $(MCC) $(archflags) $(MCCFLAGS) -c $(SRCPREFIX)$< -o $@
MXX_OBJ_RULE     ?= $(MXX) $(archflags) $(MXXFLAGS) -c $(SRCPREFIX)$< -o $@
YASM_OBJ_RULE    ?= $(YASM) $(YASMFLAGS) -o $@ $(SRCPREFIX)$<
MASM_OBJ_RULE    ?= $(MASM) $(MASMFLAGS) -Fo $@ $(SRCPREFIX)$<

#
#   Note: The rules or CXX_MD_RULE and CC_MD_RULE are first read to a .d.tmp
#   file and the *.d file created later with the install target 
#   install_project_headers.
#
ifneq ($(PLATFORM),WINDOWS)
CXX_MD_RULE      ?= $(CXX_MD) $(DEPFLAGS) $(CXXFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) ${@}.tmp
CC_MD_RULE       ?= $(CC_MD) $(DEPFLAGS) $(CFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) ${@}.tmp
else
CXX_MD_RULE      ?= $(CXX_MD) $(DEPFLAGS) $(CXXFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) ${@}
CC_MD_RULE       ?= $(CC_MD) $(DEPFLAGS) $(CFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) ${@}
endif
S_MD_RULE        ?= $(CC_MD) $(DEPFLAGS) $(SFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) $@
MCC_MD_RULE      ?= $(MCC_MD) $(DEPFLAGS) $(MCCFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) $@
MXX_MD_RULE      ?= $(MXX_MD) $(DEPFLAGS) $(MXXFLAGS) $(SRCPREFIX)$< $(DEPOUTPUT) $@
YASM_MD_RULE     ?= $(YASM) -M $(YASMFLAGS) $(SRCPREFIX)$< > $@
QRC_MD_RULE      ?= $(RCC) -list $< | sed -n 's%\([^[:space:]].\)%$(metasrc_dir)/$(QRCPREFIX)$*$(CXXSUFFIX): \1%p' >> $@


SS_RULE          ?= $(PCC) $(SFLAGS) $^ -o $@

AR_RULE          ?= cd $(obj_dir); $(AR) $@ $(patsubst $(obj_dir)/%,%,$(objs))
RC_RULE		 ?= $(RC) -fo $@ $< 

LEX_RULE         ?= $(LEX) $(LFLAGS) -o$@ $^
YACC_RULE        ?= $(YACC) $(YFLAGS) -o $(addprefix $(metasrc_dir)/,$(addsuffix $(CSUFFIX),$(basename $^))) $^
MOC_RULE         ?= $(MOC) $(MOCFLAGS) $^ -o $@
RCC_RULE	 ?= $(RCC) $(RCCFLAGS) -name $(basename $(filter %$(QRCSUFFIX),$^)) -o $@ $(filter %$(QRCSUFFIX),$<)
UI_RULE		 ?= $(UIC) $^ -o $@

CXX_LINK_RULE    ?= cd $(obj_dir) ; $(CXX_LD) $(archflags) $(LDFLAGS) $(patsubst $(obj_dir)/%,%,$(objs)) -o $@ $(libs)
CC_LINK_RULE     ?= cd $(obj_dir) ; $(CC_LD) $(archflags) $(LDFLAGS) $(patsubst $(obj_dir)/%,%,$(objs)) -o $@ $(libs)
MAYA_LINK_RULE   ?= $(MAYA_LD) $(archflags) $(LDFLAGS) $(objs) -o $@ $(libs)
SO_LINK_RULE     ?= $(CXX_LINK_RULE)
PLUGIN_LINK_RULE ?= $(SO_LINK_RULE)

CXX_SYNTAX_RULE  ?= $(CXX) -fsyntax-only $(archflags) $(CXXFLAGS) -S
CC_SYNTAX_RULE   ?= $(CC) -fsyntax-only $(archflags) $(CFLAGS) -S

COPY_LIBRARY_RULE ?= cp $< $@

#----------------------------------------------------------------------

nobuildgoals = pre_init init nuke clobber_build


ifeq ($(filter $(nobuildgoals),$(MAKECMDGOALS)),)
-include $(build_makefile)
include $(platform_makefile)
-include $(target_makefile)
include $(makefile_uses)
else
include $(platform_makefile)
-include $(target_makefile)
include $(makefile_uses)
endif

LOWERCASE_BUILD_TYPE := $(call tolower,$(BUILD_TYPE))

ifdef QT
IPATH   += $(QT)/include 
LPATH   += $(QT)/lib 
MOC     ?= $(QT)/bin/moc$(BINSUFFIX)
RCC     ?= $(QT)/bin/rcc$(BINSUFFIX)
UIC     ?= $(QT)/bin/uic$(BINSUFFIX)
QMAKE   ?= $(QT)/bin/qmake$(BINSUFFIX)
else
MOC     ?= moc$(BINSUFFIX)
RCC     ?= rcc$(BINSUFFIX)
UIC     ?= uic$(BINSUFFIX)
QMAKE   ?= qmake$(BINSUFFIX)
endif

ASCIIDOC ?= asciidoc

# Qt
ifdef QTFILES
MOCGENFILES += $(addsuffix $(CXXSUFFIX),$(addprefix $(metasrc_dir)/$(MOCPREFIX),$(QTFILES)))
endif

ifdef QTRESOURCES
QRCGENFILES += $(addsuffix $(CXXSUFFIX),$(addprefix $(metasrc_dir)/$(QRCPREFIX),$(QTRESOURCES)))
endif

cxxfiles    := $(QTFILES) $(call vargroup,CXXFILES)
mxxfiles    := $(call vargroup,MXXFILES)
mfiles      := $(call vargroup,MFILES)
cfiles      := $(call vargroup,CFILES)
yaccfiles   := $(call vargroup,YACCFILES)
lexfiles    := $(call vargroup,LEXFILES)
yasmfiles   := $(call vargroup,YASMFILES)
masmfiles   := $(call vargroup,MASMFILES)
sfiles      := $(call vargroup,SFILES)
uifiles     := $(addsuffix $(UISUFFIX),$(addprefix $(ui_dir)/,$(UIFILES)))
uihfiles    := $(addsuffix $(HSUFFIX),$(addprefix $(metasrc_dir)/$(UIPREFIX),$(UIFILES)))
GENFILES    := $(call vargroup,GENFILES)
LIBS        := $(call vargroup,LIBS) 
LIBS        := $(call boostname,LIBS) 
SYSTEM_LIBS := $(call vargroup,SYSTEM_LIBS) 
ifeq ($(PLATFORM),DARWIN)
frameworks   = $(call vargroup,FRAMEWORKS)
endif
modules     := $(call vargroup,MODULES)
rvpackages  := $(call vargroup,RVPACKAGES)
rvpackages2 := $(call vargroup,RVPACKAGES_ADDONLY)

locallibs    = $(filter-out $(SYSTEM_LIBS),$(LIBS))

files	    := $(cxxfiles) $(mxxfiles) $(mfiles) $(cfiles) $(sfiles) $(yasmfiles) $(masmfiles)
files	    := $(addprefix $(obj_dir)/,$(files))

metasrcs := $(addprefix $(metasrc_dir)/,$(addsuffix $(CXXSUFFIX),$(yaccfiles) $(lexfiles))) \
            $(uihfiles) $(MOCGENFILES) $(QRCGENFILES)
          
GENFILES    += $(metasrcs)

srcs	    :=	$(addsuffix $(CXXSUFFIX),$(cxxfiles))	\
		$(addsuffix $(MXXSUFFIX),$(mxxfiles))	\
		$(addsuffix $(MSUFFIX),$(mfiles))	\
		$(addsuffix $(CSUFFIX),$(cfiles))       \
		$(addsuffix $(CSUFFIX),$(yasmfiles))    \
		$(addsuffix $(MASMSUFFIX),$(masmfiles)) \
	        $(addsuffix $(SSUFFIX),$(sfiles))

ident	    := -DPLATFORM_$(PLATFORM) -DCOMPILER_$(COMPILER) -DARCH_$(ARCH)

# 
# *Only* GENFILES defined in a metasrc_dir which can be compiled to an object file 
#  and can have dependency files created from them are considered metaobjs.
#
metaobjs    := $(addsuffix $(OBJSUFFIX),$(basename $(patsubst $(metasrc_dir)/%,$(obj_dir)/%,$(filter \
                            $(metasrc_dir)/%$(CXXSUFFIX) \
                            $(metasrc_dir)/%$(CSUFFIX) \
                            $(metasrc_dir)/%$(YASMSUFFIX) \
                            $(metasrc_dir)/%$(MASMSUFFIX) \
                            $(metasrc_dir)/%$(SSUFFIX),$(GENFILES)))))
objs	    := $(addsuffix $(OBJSUFFIX),$(files)) $(metaobjs)

metadepfiles := $(patsubst %$(OBJSUFFIX),%.d,$(metaobjs))
ifdef USE_QT5
metadepfiles += $(addsuffix .d,$(addprefix $(obj_dir)/,$(QTRESOURCES)))
endif

depfiles     := $(addsuffix .d,$(files))

pubprojpaths ?= $(wildcard $(SRC_ROOT)/pub/*)
libprojpaths ?= $(wildcard $(SRC_ROOT)/lib/*/*)
libprojipaths ?= $(wildcard $(SRC_ROOT)/lib/[a-z]*)
binprojpaths ?= $(wildcard $(SRC_ROOT)/bin/*/*)
pluginsprojpaths ?= $(wildcard $(SRC_ROOT)/plugins/*/*)

export pubprojpaths
export libprojpaths
export libprojipaths
export binprojpaths
export pluginsprojpaths

projpaths   := $(foreach lib,$(locallibs),$(filter $(SRC_ROOT)/lib/%/$(lib),$(libprojpaths))) \
	       $(foreach lib,$(locallibs),$(filter $(SRC_ROOT)/pub/$(lib),$(pubprojpaths)))
sourcelibs  := $(notdir $(projpaths))
num_ppaths  := $(words $(projpaths))
modpaths    := $(foreach mod,$(modules),$(filter $(SRC_ROOT)/plugins/%/$(mod) \
                                                 $(SRC_ROOT)/lib/%/$(mod) \
                                                 $(SRC_ROOT)/pub/$(mod) \
                                                 $(SRC_ROOT)/bin/%/$(mod), \
                                                 $(pluginsprojpaths) $(libprojpaths) $(pubprojpaths) $(binprojpaths)))
rvpkgpaths  := $(addprefix $(SRC_ROOT)/plugins/rv-packages/,$(rvpackages))
rvpkgpaths2 := $(addprefix $(SRC_ROOT)/plugins/rv-packages/,$(rvpackages2))
libs	    := $(patsubst -l-%,-%,$(addprefix -l,$(LIBS)))
publibs     := $(filter $(locallibs),$(notdir $(pubprojpaths)))
afiles	    := $(foreach lib,$(LIBS),$(wildcard $(lib_dir)/$(LIBPREFIX)$(lib).*))
qmakeproj   := $(PROJECT).pro

winresfiles  = $(addsuffix .RES,$(addprefix $(obj_dir)/,$(WINDOWS_RC)))

ifneq ($(NEVERDYNAMIC),)
neverlibs   := $(addprefix -l,$(NEVERDYNAMIC))
newlibs     := $(foreach n,$(neverlibs),$(subst $(n),$(LD_NOLOADALL) $(n) $(LD_LOADALL),$(libs)))
libs	    := $(newlibs) $(LD_NOLOADALL) 
endif

#
# IPATHs to the project src dirs.
# NB: This could be the metasrc_dir too.
#
ifeq ($(EXCLUDE_SRCDIR_FROM_IPATH),true)
implicit_IPATH   = $(metasrc_root_dir)
else
implicit_IPATH   = . $(metasrc_root_dir)
endif

ifneq ($(words $(metaobjs)),0)
implicit_IPATH  += $(metasrc_dir)
endif

lpath 	     = $(lib_dir) $(LPATH) $(call vargroupnr,LPATH)
ipath	     = $(implicit_IPATH) \
               $(libprojipaths) \
	       $(addprefix $(SRC_ROOT)/pub/,$(publibs)) \
               $(IPATH) \
	       $(SRC_ROOT)/pub/boost \
	       $(call vargroupnr,IPATH)

post_process = $(call vargroup,POST_PROCESS)

	       #$(if $(filter $(BOOST_LIB_PATTERN),$(LIBS)),$(SRC_ROOT)/pub/boost) \

ifeq ($(PLATFORM),DARWIN)
fpath        = $(wildcard $(frameworks_dir) $(FPATH) $(call vargroupnr,FPATH))
fworks_h     = $(addprefix $(FWORKSPATH_SWITCH),$(fpath))
fworks	     = $(addprefix -framework ,$(frameworks)) 
endif

CXXFLAGS    += $(version_defs) $(fworks_h) \
	       $(call vargroupnr,CXXFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
MXXFLAGS    += $(version_defs) $(fworks_h) \
	       $(call vargroupnr,MXXFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
MCCFLAGS    += $(version_defs) $(fworks_h) \
	       $(call vargroupnr,MCCFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
CFLAGS	    += $(version_defs) $(fworks_h) \
	       $(call vargroupnr,CFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
YASMFLAGS   += $(version_defs) \
	       $(call vargroupnr,YASMFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
MASMFLAGS   += $(version_defs) \
	       $(call vargroupnr,MASMFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
SFLAGS	    += $(version_defs) $(fworks_h) \
	       $(call vargroupnr,SFLAGS) \
               $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
LDFLAGS	    += $(call vargroupnr,LDFLAGS) \
	       $(fworks_h) $(fworks) \
               $(addprefix $(LOADPATH_SWITCH),$(lpath))
MOCFLAGS    += $(call vargroupnr,MOCFLAGS) \
	       $(addprefix $(INCLUDE_SWITCH),$(ipath)) $(ident)
RCCFLAGS    += $(call vargroupnr,RCCFLAGS)

num_export   = $(words $(PUBLIC))
export_h     = $(addsuffix $(HSUFFIX),$(PUBLIC))

ifndef YY
YY	     = yy
endif

YFLAGS	    += -dv -p $(YY)
LFLAGS	    += -P$(YY)

#----------------------------------------------------------------------
#
#	Adjust target 
#

ifeq ($(TYPE),PRECOMPILED_LIBRARIES)
target    := $(obj_dir)/$(PROJECT)_stub
libraries := $(addprefix $(lib_dir)/,$(LIBRARIES))
endif

ifeq ($(TYPE),ZIP_PACKAGE)
target    := $(plugin_dir)/Packages/$(PROJECT).zip
endif

ifeq ($(TYPE),RVPKG)
# scarf the version right out of the PACKAGE file for rvpkg
pkgversion := $(subst version: ,,$(shell grep ^version: PACKAGE))
target    := $(BUILD_ROOT)/rvpkg/$(PROJECT)-$(pkgversion).rvpkg
endif

ifeq ($(TYPE),PLUGIN)
target    := $(plugin_dir)/$(PROJECT)$(PLUGINSUFFIX)
LDFLAGS   += $(DYNAMIC)
CXXFLAGS  += $(SHAREFLAGS)
MXXFLAGS  += $(SHAREFLAGS)
CFLAGS	  += $(SHAREFLAGS)
MCCFLAGS  += $(SHAREFLAGS)
endif

ifeq ($(TYPE),TWKFB_PLUGIN)
target    := $(plugin_dir)/$(PROJECT)$(PLUGINSUFFIX)
LDFLAGS   += $(DYNAMIC)
CXXFLAGS  += $(SHAREFLAGS)
MXXFLAGS  += $(SHAREFLAGS)
CFLAGS	  += $(SHAREFLAGS)
MCCFLAGS  += $(SHAREFLAGS)
endif

ifeq ($(TYPE),TWKMOVIE_PLUGIN)
target    := $(plugin_dir)/$(PROJECT)$(PLUGINSUFFIX)
LDFLAGS   += $(DYNAMIC)
CXXFLAGS  += $(SHAREFLAGS)
MXXFLAGS  += $(SHAREFLAGS)
CFLAGS	  += $(SHAREFLAGS)
MCCFLAGS  += $(SHAREFLAGS)
endif

ifeq ($(TYPE),MAYA_PLUGIN)
PLUGIN_DIR   = plugins/maya
SCRIPTS_DIR  = scripts/mel
target	    := $(plugin_dir)/$(PROJECT)$(PLUGINSUFFIX)
LDFLAGS	    += $(DYNAMIC)
CXXFLAGS    += $(SHAREFLAGS)
MXXFLAGS    += $(SHAREFLAGS)
CFLAGS	    += $(SHAREFLAGS)
MCCFLAGS    += $(SHAREFLAGS)
endif

ifeq ($(TYPE),EXECUTABLE)
target	    := $(bin_dir)/$(PROJECT)$(BINSUFFIX)
SCRIPTS_DIR  = $(bin_dir)
tcmd	     = for proj in $(rvpkgpaths); do $(MAKE) -s --no-print-directory target_info -C $$proj ; done;
rvpkg_targets = $(shell $(tcmd))
mcmd	      = for proj in $(rvpkgpaths); do $(MAKE) -s -C $$proj ; done;
tcmd2	      = for proj in $(rvpkgpaths2); do $(MAKE) -s --no-print-directory target_info -C $$proj; done;
rvpkg_targets2 = $(shell $(tcmd2))
mcmd2         = for proj in $(rvpkgpaths2); do $(MAKE) -s -C $$proj ; done;
endif

ifeq ($(TYPE),EXECUTABLE_WITH_PLUGINS)
target	    := $(bin_dir)/$(PROJECT)$(BINSUFFIX)
LDFLAGS	    += $(DYNPUBLIC) $(LD_LOADALL)
SCRIPTS_DIR  = scripts/$(PROJECT)
tcmd	      = for proj in $(rvpkgpaths); do $(MAKE) -s --no-print-directory target_info -C $$proj; done;
rvpkg_targets = $(shell $(tcmd))
mcmd          = for proj in $(rvpkgpaths); do $(MAKE) -s -C $$proj; done;
tcmd2	      = for proj in $(rvpkgpaths2); do $(MAKE) -s --no-print-directory target_info -C $$proj; done;
rvpkg_targets2 = $(shell $(tcmd2))
mcmd2         = for proj in $(rvpkgpaths2); do $(MAKE) -s -C $$proj; done;
endif

ifeq ($(TYPE),VERBATIM_DIRECTORY)
target_dir = $(BUILD_ROOT)/$(TARGET)
target     = $(addprefix $(target_dir)/,$(FILES))
endif

#
#   This one has some weird stuff. If self_contained is in MAKECMDGOALS
#   then we need to call $(dybundlecmd) to find out what dylibs to copy and
#   generate ld arguments which will look for the dylibs in the bundle
#
ifeq ($(PLATFORM),DARWIN)
ifneq ($(filter NSAPPLICATION DISTRIBUTION_%,$(TYPE)),)
ifdef PROJECT
bundle_name  = $(PROJECT).app
endif
ifdef PACKAGE
bundle_name  = $(APPLICATION).app
endif

PLUGIN_DIR   = $(patsubst $(BUILD_ROOT)/%,%,$(contents_dir)/PlugIns)
SCRIPTS_DIR  = $(patsubst $(BUILD_ROOT)/%,%,$(contents_dir)/Scripts)
bundle_root  = Applications
target	    := $(osbin_dir)/$(PROJECT)
bundle_lib   = lib
ifneq ($(LINK_TYPE),STATIC)
LDFLAGS	    += $(DYNPUBLIC) $(LD_LOADALL) 
endif
dybundlecmd  = otool $(LOADPATH_SWITCH) $(target) | awk '{ print $$1 }' | grep -v : | grep dylib | grep -v "/usr/lib"
tcmd = for proj in $(rvpkgpaths); do $(MAKE) -s --no-print-directory target_info -C $$proj; done;
rvpkg_targets = $(shell $(tcmd))
mcmd = for proj in $(rvpkgpaths); do $(MAKE) -s -C $$proj; done;
tcmd2	      = for proj in $(rvpkgpaths2); do $(MAKE) -s --no-print-directory target_info -C $$proj; done;
rvpkg_targets2 = $(shell $(tcmd2))
mcmd2         = for proj in $(rvpkgpaths2); do $(MAKE) -s -C $$proj; done;
endif
endif

ifeq ($(TYPE),MU_SOURCE_MODULE)
target       = $(addprefix $(plugin_dir)/Mu/,$(MUFILES))
endif

ifeq ($(TYPE),PYTHON_SOURCE_MODULE)
target       = $(addprefix $(plugin_dir)/Python/,$(PYFILES))
endif

ifeq ($(TYPE),TEST)
bin_dir	    := $(obj_dir)
target	    := $(bin_dir)/test
endif

ifeq ($(TYPE),LIBRARY)
target	    := $(lib_dir)/$(LIBPREFIX)$(PROJECT)$(ARSUFFIX)
endif

ifeq ($(TYPE),SHARED_LIBRARY)
target	    := $(lib_dir)/$(LIBPREFIX)$(PROJECT)$(SOSUFFIX)
LDFLAGS	    += $(SHARED)
CXXFLAGS    += $(SHAREFLAGS)
MXXFLAGS    += $(SHAREFLAGS)
CFLAGS	    += $(SHAREFLAGS)
MCCFLAGS    += $(SHAREFLAGS)
endif

ifeq ($(TYPE),SYSTEM_LIBRARY)
target	    := $(SYSTEM_LIBRARY)
endif

ifeq ($(TYPE),PYTHON_CMODULE)
ifeq ($(PLATFORM),DARWIN)
target	    := $(PYLIB_DYNLOAD)/$(PROJECT).so
endif
ifeq ($(PLATFORM),LINUX)
target	    := $(PYLIB_DYNLOAD)/$(PROJECT)$(SOSUFFIX)
endif
ifeq ($(PLATFORM),WINDOWS)
target	    := $(PYLIB_DYNLOAD)/$(PROJECT).pyd
endif
LDFLAGS	    += $(DYNAMIC)
endif

ifeq ($(TYPE),DOCUMENTATION)
target	    := $(addprefix $(pdf_dir)/,$(addsuffix .pdf,$(PDF))) \
	       $(addprefix $(info_dir)/,$(addsuffix .info,$(INFO))) \
	       $(addprefix $(html_dir)/,$(addsuffix .xhtml,$(XHTML))) \
	       $(addprefix $(html_dir)/,$(addsuffix .html,$(HTML))) \
	       $(addprefix $(html_dir)/,$(FONTS))  \
	       $(addprefix $(html_dir)/,$(CSS)) \
	       $(addprefix $(html_dir)/,$(notdir $(CSSIMAGES)))
GENFILES    += $(addprefix $(PDF).,aux cp fn fns ltx ky log pg toc tp vr) \
	       $(PDF).pdf $(INFO).info \
	       $(addprefix $(html_dir)/images/,$(basename $(HTMLIMAGES)))
endif

ifeq ($(PLATFORM),WINDOWS)
objs        += $(winresfiles)
endif

symbol_targets  = PLUGIN EXECUTABLE SHARED
collect_symbols = echo "skipping symbols for "
collect_symbols_for_real = $(SRC_ROOT)/build/symbols_$(PLATFORM)

#----------------------------------------------------------------------
#
#	Implicit Rules
#

# 
#  For QT5 we need to append qml files to the dependency of the qrc cpp file.
#
ifdef USE_QT5
$(obj_dir)/%.d: %$(QRCSUFFIX)
ifneq ($(PLATFORM),WINDOWS)
	@echo QRC Dependencies $(basename $(notdir $@)).d
endif
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(QRC_MD_RULE)
endif

$(obj_dir)/%.d: $(metasrc_dir)/%$(CXXSUFFIX) $(GENFILES)
ifneq ($(PLATFORM),WINDOWS)
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CXX_MD_RULE); \
	if [ $$? -eq 0 ];  then echo "install_project_headers \\" > $@; cat ${@}.tmp >> $@; fi;\
        if [ -f ${@}.tmp ]; then $(RM) ${@}.tmp; fi
else
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CXX_MD_RULE)
endif

$(obj_dir)/%.d: $(metasrc_dir)/%$(CSUFFIX) $(GENFILES)
ifneq ($(PLATFORM),WINDOWS)
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CC_MD_RULE); \
	if [ $$? -eq 0 ];  then echo "install_project_headers \\" > $@; cat ${@}.tmp >> $@; fi; \
        if [ -f ${@}.tmp ]; then $(RM) ${@}.tmp; fi
else
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CC_MD_RULE)
endif

$(obj_dir)/%.d: %$(CXXSUFFIX) $(GENFILES) 
ifneq ($(PLATFORM),WINDOWS)
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CXX_MD_RULE); \
	if [ $$? -eq 0 ];  then echo "install_project_headers \\" > $@; cat ${@}.tmp >> $@; fi;\
        if [ -f ${@}.tmp ]; then $(RM) ${@}.tmp; fi
else
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CXX_MD_RULE)
endif

$(obj_dir)/%.d: %$(CSUFFIX) $(GENFILES) 
ifneq ($(PLATFORM),WINDOWS)
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CC_MD_RULE); \
	if [ $$? -eq 0 ];  then echo "install_project_headers \\" > $@; cat ${@}.tmp >> $@; fi; \
        if [ -f ${@}.tmp ]; then $(RM) ${@}.tmp; fi
else
	@$(MKDIR) $(dir $@)
	$(SHOWCMD) $(CC_MD_RULE)
endif

$(obj_dir)/%.d: %$(YASMSUFFIX) $(GENFILES)
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD)$(YASM_MD_RULE)

$(obj_dir)/%.d: %$(SSUFFIX) $(GENFILES) 
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD)$(S_MD_RULE)

$(obj_dir)/%.d: %$(MSUFFIX) $(GENFILES) 
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD)$(MCC_MD_RULE)

$(obj_dir)/%.d: %$(MMSUFFIX) $(GENFILES) 
	@echo Dependencies $(basename $(notdir $@)).d
	@$(MKDIR) $(dir $@)
	$(SHOWCMD)$(MXX_MD_RULE)

#
#  Object file rules
#

$(obj_dir)/%$(OBJSUFFIX): $(metasrc_dir)/%$(CXXSUFFIX) $(PROJECT_MAKEFILE)
ifneq ($(PLATFORM),WINDOWS)
	@echo Compiling $(basename $(notdir $@))$(CXXSUFFIX)
endif
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(CXX_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): $(metasrc_dir)/%$(CSUFFIX) $(PROJECT_MAKEFILE)
ifneq ($(PLATFORM),WINDOWS)
	@echo Compiling $(basename $(notdir $@))$(CSUFFIX)
endif
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(CC_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(MSUFFIX) $(PROJECT_MAKEFILE)
	@echo Compiling $(basename $(notdir $@))$(MSUFFIX)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(MCC_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(CXXSUFFIX) $(PROJECT_MAKEFILE)
ifneq ($(PLATFORM),WINDOWS)
	@echo Compiling $(basename $(notdir $@))$(CXXSUFFIX)
endif
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(CXX_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(YASMSUFFIX) $(PROJECT_MAKEFILE)
	@echo Compiling $(basename $(notdir $@))$(YASMSUFFIX)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(YASM_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(MASMSUFFIX) $(PROJECT_MAKEFILE)
	@echo Compiling $(basename $(notdir $@))$(MASMSUFFIX)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(MASM_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(CSUFFIX) $(PROJECT_MAKEFILE)
ifneq ($(PLATFORM),WINDOWS)
	@echo Compiling $(basename $(notdir $@))$(CSUFFIX)
endif
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(CC_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(SSUFFIX) $(PROJECT_MAKEFILE)
	@echo Compiling $(basename $(notdir $@))$(SSUFFIX)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(S_OBJ_RULE)

$(obj_dir)/%$(OBJSUFFIX): %$(MXXSUFFIX) $(PROJECT_MAKEFILE)
	@echo Compiling $(basename $(notdir $@))$(MXXSUFFIX)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(MXX_OBJ_RULE)

$(lib_dir)/%$(ARSUFFIX): $(objs) $(PROJECT_MAKEFILE)
	@echo Archiving $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; if [ -f $@ ]; then $(RM) $@; fi ; $(AR_RULE)

$(obj_dir)/%.RES: %.RC $(PROJECT_MAKEFILE)
	@echo Resource RC File $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(RC_RULE)

#
#  Yacc and Lex rules only build C++ files.
#

$(metasrc_dir)/%$(CXXSUFFIX): %$(LSUFFIX)
	@echo Lex $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(LEX_RULE)
	@chmod -x $@

$(metasrc_dir)/%$(CXXSUFFIX) $(metasrc_dir)/%$(HSUFFIX): %$(YSUFFIX)
	@echo Yacc $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(YACC_RULE)
ifdef YYFILTER
	@cat $(addprefix $(metasrc_dir)/,$(addsuffix $(CSUFFIX),$(basename $^))) | $(YYFILTER) | sed 's%$(addprefix $(metasrc_dir)/,$(addsuffix $(CSUFFIX),$(basename $^)))%$(addprefix $(metasrc_dir)/,$(addsuffix $(CXXSUFFIX),$(basename $^)))%g'  > $(addprefix $(metasrc_dir)/,$(addsuffix $(CXXSUFFIX),$(basename $^)))
else
	@cat $(addprefix $(metasrc_dir)/,$(addsuffix $(CSUFFIX),$(basename $^))) | sed 's%$(addprefix $(metasrc_dir)/,$(addsuffix $(CSUFFIX),$(basename $^)))%$(addprefix $(metasrc_dir)/,$(addsuffix $(CXXSUFFIX),$(basename $^)))%g'  > $(addprefix $(metasrc_dir)/,$(addsuffix $(CXXSUFFIX),$(basename $^)))
endif

#
#   Qt
#
#   For ui files: do the same thing that qmake does: make ui_Foo.h
#   from Foo.ui
#

$(metasrc_dir)/$(MOCPREFIX)%$(CXXSUFFIX): %$(HSUFFIX)
	@echo Moc File $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(MOC_RULE)
	@chmod -x $@

$(metasrc_dir)/$(QRCPREFIX)%$(CXXSUFFIX): %$(QRCSUFFIX)
	@echo QResource $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(RCC_RULE)
	@chmod -x $@

$(metasrc_dir)/$(UIPREFIX)%$(HSUFFIX): %$(UISUFFIX)
	@echo Designer File $(notdir $@)
	$(SHOWCMD)$(MKDIR) $(dir $@) ; $(UI_RULE)
	@chmod -x $@

$(ui_dir)/%$(UISUFFIX): %$(UISUFFIX)
	$(MKDIR) $(dir $@) ; cp $^ $@

#
#   Assembly files that need to be run through gcc -E
#

%.s: %.S
	$(SS_RULE)

#
#   Documentation files
#

#$(pdf_dir)/%.pdf: %.tm
#	$(TEXMACS) -c $^ $@
#	$(MKDIR) $(pdf_dir)
#	cp *.pdf $(pdf_dir)

$(pdf_dir)/%.pdf: %.lyx
	$(RM) ./$(notdir $@)
	$(LYX) -e pdf2 $^
	$(MKDIR) $(pdf_dir)
	cp *.pdf $(pdf_dir)

$(info_dir)/%.info: %.texi
	$(MKDIR) $(info_dir)
	$(MAKEINFO) $^ -o $@

$(html_dir)/%.html: %.texi
	$(MAKEHTML) $^
	$(MKDIR) $(html_dir)
ifeq ($(PLATFORM),WINDOWS)
	mv $(basename $(notdir $^))/* $(html_dir)
else
	mv *.html $(html_dir)
endif

$(html_dir)/%.png: images/%.png
	$(MKDIR) $(@D) ; cp $^ $@

$(html_dir)/%.ttf: %.ttf
	cp $^ $(html_dir)/

$(html_dir)/%.css: %.css
	cp $^ $(html_dir)/

$(html_dir)/%.html: %.asciidoc
	$(MKDIR) $(html_dir)
	$(ASCIIDOC) $^
	mv $(addsuffix .html,$(basename $^)) $(BUILD_ROOT)/html
ifdef HTMLIMAGES
	mkdir -p $(html_dir)/images
	cp -f $(HTMLIMAGES) $(html_dir)/images
endif

#
#  Now we build xhtml files on the way to html from lyx sources (see below)
#
#$(html_dir)/%.html: %.lyx
#	$(MKDIR) $(html_dir)
#	$(SRC_ROOT)/build/elyxer.py --quiet --css $(addsuffix .css,$(basename $^)) $^ $@
#	awk '{ gsub(/\xe2\x80\x99/,"\x27"); print }' < $@ | sed -e 's/@\\[^@]*@//' > $(addsuffix .tmp,$@)
#	mv $(addsuffix .tmp,$@) $@
#	cp $(addsuffix .css,$(basename $^)) $(html_dir)

$(html_dir)/%.html: %.lyx
	$(MKDIR) $(html_dir)
	$(MKDIR) $(html_temp_dir)
	cp $^ $(html_temp_dir)
	ln -s $(shell pwd)/images $(html_temp_dir)/images
	cd $(html_temp_dir); $(LYX) -e xhtml $^; $(RM) $^
	cp $(addsuffix .css,$(basename $^)) $(html_temp_dir)
	$(RM) $(html_temp_dir)/images
	mv $(html_temp_dir)/* $(html_dir)
	sed -e 's#\(<a id=[^>]*>\)#\1</a>#g' $(addsuffix .xhtml,$(basename $@)) | $(SRC_ROOT)/build/html4posterity.py > $@
	$(RM) $(addsuffix .xhtml,$(basename $@))
	$(RRM) $(html_temp_dir)

$(html_dir)/%.xhtml: %.lyx
	$(MKDIR) $(html_dir)
	$(MKDIR) $(html_temp_dir)
	cp $^ $(html_temp_dir)
	ln -s $(shell pwd)/images $(html_temp_dir)/images
	cd $(html_temp_dir); $(LYX) -e xhtml $^; $(RM) $^
	cp $(addsuffix .css,$(basename $^)) $(html_temp_dir)
	$(RM) $(html_temp_dir)/images
	mv $(html_temp_dir)/* $(html_dir)
	$(RRM) $(html_temp_dir)

$(html_dir)/%.html: %.html
	cp $^ $@

$(html_dir)/%_toc.html: %.lyx
	$(MKDIR) $(html_dir)
	$(SRC_ROOT)/build/elyxer.py --quiet --css $(addsuffix _toc.css,$(basename $^))  \
	    --toc --target contentframe $^ $@
	cp $(addsuffix _toc.css,$(basename $^)) $(html_dir)
	$(SRC_ROOT)/build/elyxer_toc_munge.py $@ $(addsuffix .html,$(basename $^))


# USING LYX
# $(html_dir)/%.html: %.lyx
# 	$(LYX) -e html $^
# 	if [ -e $(subst .lyx,,$^).css ] ; \
# 		then cat $(subst .lyx,,$^).html.LyXconv/$(subst .lyx,,$^).css \
# 			 $(subst .lyx,,$^).css \
# 			> /tmp/x.css && \
#                         cp /tmp/x.css $(subst .lyx,,$^).html.LyXconv/$(subst .lyx,,$^).css ; \
# 	fi
# 	$(MKDIR) $(html_dir)
# 	cp $(subst .lyx,,$^).html.LyXconv/* $(html_dir)/

$(pdf_dir)/%.pdf: %.texi
	$(MAKEPDF) $^
	$(MKDIR) $(pdf_dir)
	cp *.pdf $(pdf_dir)
	$(MAKE) clean_pdf_mess

%.icns: $(wildcard %.iconset/icon_*.png)
	iconutil -c icns -o $@ $(basename $(notdir $@)).iconset

.PRECIOUS: $(obj_dir)/%$(OBJSUFFIX)
.PRECIOUS: %$(HSUFFIX)
.PRECIOUS: %$(CSUFFIX)
.PRECIOUS: %$(SSUFFIX)

ifneq ($(GENFILES),)
.PRECIOUS: $(metasrc_dir)/%
endif
ifneq ($(metaobjs),)
.PRECIOUS: $(metasrc_dir)/%$(CXXSUFFIX) $(metasrc_dir)/%$(CSUFFIX) \
           $(metasrc_dir)/%$(HSUFFIX)
endif


#----------------------------------------------------------------------
#
#	The default target
#

default: $(target)
ifdef AUXFILES
	$(MKDIR) $(aux_dir)
	$(INSTALL) $(AUXFILES) $(aux_dir)
endif

#----------------------------------------------------------------------
#
#	Don't get in the chicken/egg situation with .d files and these
#	targets. These targets should not require the depedancies
#	exist. 
#

noincludegoals +=   clean clobber clobber_build genfiles project_info files_info \
		    target_info pre_init init nuke configure_info echo_all \
		    flag_info help rebuild showdag showdag_nocull showdag_text

ifeq ($(filter $(noincludegoals),$(MAKECMDGOALS)),)
# NB: The depfiles and metadepfiles are include by makefile_d.
-include $(makefile_d)
endif

#----------------------------------------------------------------------
#
#	Explicit Rules
#

# This multi target is really problematic and we need to replace it with
# a single rvpkg project.
ifeq ($(REBUILD_TARGET),)
ifneq ($(wildcard $(rvpkg_targets)),)
$(rvpkg_targets):
	@+$(MAKE) rvpkgs 
endif
endif

ifeq ($(TYPE),PRECOMPILED_LIBRARIES)
$(target): $(libraries)
	@$(MKDIR) $(dir $@)
	@touch $@
	@echo $(PROJECT) installed
endif

ifeq ($(TYPE),ZIP_PACKAGE)
$(target): $(FILES) PACKAGE
	@mkdir -p $(dir $@) ; $(RM) $@ \
	if [ ! -e PACKAGE ] ; \
	    then echo "ERROR: Missing PACKAGE file."; \
	    else echo zip $@ PACKAGE $(FILES) && zip $@ PACKAGE $(FILES); \
	fi
endif

ifeq ($(TYPE),RVPKG)
$(target): $(FILES) PACKAGE
	@mkdir -p $(dir $@) ; $(RM) $@ ; \
	if [ ! -e PACKAGE ] ; \
	    then echo "ERROR: Missing PACKAGE file."; \
	    else echo zip $@ PACKAGE $(FILES) && zip $@ PACKAGE $(FILES); \
	fi
endif

ifeq ($(TYPE),NSAPPLICATION)
version_defs = -DMAJOR_VERSION=$(MAJOR_VERSION) \
               -DMINOR_VERSION=$(MINOR_VERSION) \
               -DREVISION_NUMBER=$(REVISION_NUMBER) \
               -DRELEASE_DESCRIPTION=\"$(RELEASE_DESCRIPTION)\" 


$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE) $(info_plist) *.lproj/* $(wildcard $(rvpkg_targets)) $(RESOURCES)
	$(SHOWCMD)$(MKDIR) $(bundle_dir) $(contents_dir) $(osbin_dir) \
		 $(resource_dir) $(plugin_dir)
	$(SHOWCMD)+$(MAKE) rvpkgs
	$(RRM) $(resource_dir)/*.lproj/*~.nib
	$(RRM) $(resource_dir)/*.lproj/*~
	$(RRM) $(resource_dir)/*.lproj/CVS
ifneq ($(wildcard *.lproj),)
	@cp -rf *.lproj $(resource_dir)
endif
ifdef RESOURCES
	@cp -rf $(RESOURCES) $(resource_dir)
endif
	$(CXX_LINK_RULE)
	$(SHOWCMD)$(MKDIR) $(contents_dir)/PlugIns ; \
	$(post_process)

self_contained: 
	makeAppBundle $(dir $(target)) $(contents_lib_dir) $(frameworks_dir)
endif

ifeq ($(TYPE),MU_SOURCE_MODULE)
$(target): $(MUFILES)
	$(SHOWCMD)echo Mu Source Module $(notdir $@) ; \
	 $(MKDIR) $(plugin_dir)/Mu ; \
	 $(RM) $(addprefix $(plugin_dir)/Mu/,$(notdir $@)) ; \
	 $(INSTALL) $(notdir $@) $(plugin_dir)/Mu/
endif

ifeq ($(TYPE),PYTHON_SOURCE_MODULE)
$(target): $(PYFILES)
	$(SHOWCMD)echo Python Source Module $(notdir $@) ; \
	 $(MKDIR) $(dir $@) ; \
	 $(RM) $@ ; \
	 $(INSTALL) $(subst $(plugin_dir)/Python/,,$@) $(dir $@)
endif

ifeq ($(TYPE),VERBATIM_DIRECTORY)
$(target): $(FILES)
	$(SHOWCMD)echo Copying $(notdir $@) ; \
	 $(MKDIR) $(target_dir) ; \
	 $(RRM) $(addprefix $(target_dir)/,$(notdir $@)) ; \
	 cp -r $(notdir $@) $(target_dir)
endif

ifeq ($(TYPE),DOCUMENTATION)
$(target): $(DOCS)
endif

ifeq ($(TYPE),EXECUTABLE)
version_defs = -DMAJOR_VERSION=$(MAJOR_VERSION) \
               -DMINOR_VERSION=$(MINOR_VERSION) \
               -DREVISION_NUMBER=$(REVISION_NUMBER) \
	       -DRELEASE_DESCRIPTION=\"$(RELEASE_DESCRIPTION)\"

$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	$(SHOWCMD)echo Linking $(notdir $@) ; \
	 $(MKDIR) $(bin_dir) ; \
	 $(RM) $(target).bin ; \
	 $(CXX_LINK_RULE)
	 $(SHOWCMD)$(collect_symbols) $@ $(notdir $@) ; \
	 $(post_process) 

$(target).bin:
	@$(MAKE) $(target) ; $(MV) $(target) $(target).bin
endif

ifeq ($(TYPE),EXECUTABLE_WITH_PLUGINS)
version_defs = -DMAJOR_VERSION=$(MAJOR_VERSION) \
               -DMINOR_VERSION=$(MINOR_VERSION) \
               -DREVISION_NUMBER=$(REVISION_NUMBER) \
	       -DRELEASE_DESCRIPTION=\"$(RELEASE_DESCRIPTION)\"

$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE) $(wildcard $(rvpkg_targets))
ifneq ($(rvpkg_targets),)
	@+$(MAKE) rvpkgs
endif
	$(SHOWCMD)echo Linking $(notdir $@) ; \
	 $(MKDIR) $(bin_dir) ; \
	 $(RM) $(target).bin ; \
	 $(CXX_LINK_RULE)
	 $(SHOWCMD)$(MKDIR) $(BUILD_ROOT)/plugins ; \
	 $(collect_symbols) $@ $(notdir $@) ; \
	 $(post_process)

$(target).bin: 
	@$(MAKE) $(target) ; $(MV) $(target) $(target).bin
endif

ifeq ($(TYPE),LIBRARY)
$(target): $(deplibs) $(objs) $(uifiles) $(PROJECT_MAKEFILE)
	@echo Archiving $(notdir $@)
ifneq ($(num_export),0)
	@$(MKDIR) $(header_dir)
endif
ifneq ($(words $(objs)),0)
	$(SHOWCMD)if [ -f $@ ]; then $(RM) $@; fi ; $(AR_RULE) ; $(post_process)
endif
	@$(RM) $(addsuffix $(SOSUFFIX),$(basename $@))
ifdef SECONDARY_TARGETS
	$(MAKE) $(SECONDARY_TARGETS)
endif
endif

ifeq ($(TYPE),SHARED_LIBRARY)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	@echo Linking Shared Object $(notdir $@)
	$(SHOWCMD)$(SO_LINK_RULE)
	$(SHOWCMD)$(collect_symbols) $@ $(notdir $@) 
ifeq ($(WINDOWS_AUTO_EXPORT_DLL),TRUE)
ifdef SO_POST_PROCESS
	$(SHOWCMD)$(SO_POST_PROCESS)
endif
endif
ifneq ($(PLATFORM),WINDOWS)
	@$(RM) $(addsuffix $(ARSUFFIX),$(basename $@))
endif
ifdef SECONDARY_TARGETS
	$(MAKE) $(SECONDARY_TARGETS)
endif
endif

ifeq ($(TYPE),SYSTEM_LIBRARY)
$(target): 
	@echo SYSTEM LIBRARY $(target) IS MISSING
	$(error) bad project
endif

ifeq ($(TYPE),PLUGIN)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	$(SHOWCMD)echo Plugin $(notdir $@) ; \
	$(MKDIR) $(plugin_dir) ; \
	$(PLUGIN_LINK_RULE)
	$(SHOWCMD)$(collect_symbols) $@ $(notdir $@) 
ifneq ($(words $(SCRIPTS)),0)
	@$(MKDIR) $(scripts_dir) ; \
	$(INSTALL) $(SCRIPTS) $(scripts_dir)
endif
endif

ifeq ($(TYPE),PYTHON_CMODULE)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	$(SHOWCMD)echo Python C Module $(notdir $@) ; \
	$(MKDIR) $(PYLIB_DYNLOAD) ; \
	$(PLUGIN_LINK_RULE) 
endif

ifeq ($(TYPE),TWKFB_PLUGIN)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	$(SHOWCMD)echo FB Plugin $(notdir $@) ; \
	$(MKDIR) $(plugin_dir) ; \
	$(PLUGIN_LINK_RULE)
	$(SHOWCMD)$(collect_symbols) $@ $(notdir $@) 
ifneq ($(words $(SCRIPTS)),0)
	@$(MKDIR) $(scripts_dir) ; \
	 $(INSTALL) $(SCRIPTS) $(scripts_dir)
endif
	$(SHOWCMD)$(BUILD_ROOT)/bin/makeFBIOformats $(plugin_dir)
endif

ifeq ($(TYPE),TWKMOVIE_PLUGIN)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE)
	$(SHOWCMD)echo Movie Plugin $(notdir $@) ; \
	$(MKDIR) $(plugin_dir) ; \
	$(PLUGIN_LINK_RULE)
	$(SHOWCMD)$(collect_symbols) $@ $(notdir $@)
ifneq ($(words $(SCRIPTS)),0)
	@$(MKDIR) $(scripts_dir) ; \
	 $(INSTALL) $(SCRIPTS) $(scripts_dir)
endif
	$(SHOWCMD)$(BUILD_ROOT)/bin/makeMovieIOformats $(plugin_dir)
endif

ifeq ($(TYPE),MAYA_PLUGIN)
$(target): $(deplibs) $(objs) $(PROJECT_MAKEFILE) $(SCRIPTS)
	$(MKDIR) $(plugin_dir)
	$(MKDIR) $(scripts_dir)
	$(MAYA_LINK_RULE)
ifneq ($(words $(SCRIPTS)),0)
	$(INSTALL) $(SCRIPTS) $(scripts_dir)
endif
endif

#----------------------------------------------------------------------
#
#	Other Rules
#

include $(makefile_external_deplibs_rules)

.PHONY: clean clobber clobber_build nuke genfiles pre_init  init run gdb info
.PHONY: html default qmake symbols rebuild showdag showdag_nocull showdag_text

symbols:
ifneq (,$(findstring $(TYPE),$(symbol_targets)))
	$(collect_symbols) $(target) $(notdir $(target))
else
	@true
endif

$(info_plist): Info.plist
	$(MKDIR) $(contents_dir)
	if [ -f $@ ] ; then chmod +w $@ ; fi
	year=`date "+%Y"` ; sed -e "s/MAJOR_VERSION/$(MAJOR_VERSION)/g" \
            -e "s/MINOR_VERSION/$(MINOR_VERSION)/g" \
            -e "s/REVISION_NUMBER/$(REVISION_NUMBER)/g" \
            -e "s/YEAR/"$$year"/g" \
            -e "s/BUNDLE_SHORT_VERSION/$(BUNDLE_SHORT_VERSION)/g" \
            -e "s/BUNDLE_VERSION/$(BUNDLE_VERSION)/g" \
            -e "s/BUNDLE_IDENTIFIER/$(BUNDLE_IDENTIFIER)/g" \
            Info.plist > $@

Info.plist:
	makeInfoPlist

ifeq ($(PLATFORM),LINUX)
ifdef WRAPPER
wrapper: $(target).bin
	make scripts
	cp $(WRAPPER) $(target)
	chmod 755 $(target)
else
wrapper: $(target)
	@$(ECHO) Project has no wrapper
endif
else
wrapper: $(target)
	@$(ECHO) wrapper ignored on non-LINUX platforms
endif

ifdef SCRIPTS
scripts: $(SCRIPTS)
	$(MKDIR) $(scripts_dir)
	$(INSTALL) $(SCRIPTS) $(scripts_dir)
else
scripts:
	@$(ECHO) Project has no scripts
endif

clean_pdf_mess:
	$(RRM) $(addprefix $(PDF).,aux cp fn fns ky log pg toc tp vr) 

ifeq ($(filter DISTRIBUTION_%,$(TYPE)),)
clean:
	@echo Cleaning $(PROJECT)
ifneq ($(TYPE),SYSTEM_LIBRARY)
	$(SHOWCMD)$(RRM) $(objs) $(target) $(target).bin.$(PROCESSOR) $(GENFILES)
endif
ifdef EXTRA_CLEAN
	$(SHOWCMD)$(RRM) $(EXTRA_CLEAN)
endif
else
clean:
	@echo "Cleaning $(PACKAGE) installation"
	$(RRM) $(INSTALL_ROOT) $(DMG_ROOT) $(PKG_ROOT) $(archive) $(symbol_archive)
endif


relink:
	@echo Relink $(notdir $@)
	$(SHOWCMD)$(RRM) $(target) $(target).bin.$(PROCESSOR)
	$(SHOWCMD)$(MAKE)

ifeq ($(filter DISTRIBUTION_%,$(TYPE)),)
clobber: clean
	@echo Clobbering $(PROJECT)
	$(SHOWCMD)$(RRM) $(obj_dir) $(metasrc_dir); if [ -f $(qmakeproj) ] ; then $(RM) $(qmakeproj) ; fi
ifeq ($(TYPE),NSAPPLICATION)
	$(SHOWCMD)$(RRM) $(bundle_dir)
endif
ifeq ($(PLATFORM),DARWIN)
	$(SHOWCMD)if [ -d $(PROJECT).xcodeproj ] ; then $(RRM) $(PROJECT).xcodeproj ; fi
	$(SHOWCMD)if [ -d build ] ; then $(RRM) build ; fi
endif
ifeq ($(PLATFORM),WINDOWS)
ifneq ($(NOCLOBBER_VS_FILES),true)
	$(SHOWCMD)$(RRM) debug release ; if [ -f $(PROJECT).vcproj ] ; then $(RM) $(PROJECT).vcproj* vc*.idb vc*.pdb ; fi ; if [ -f $(PROJECT).sln ] ; then $(RM) $(PROJECT).sln ; fi ; if [ -f $(BUILD_ROOT)/objects/$(PROJECT).sbr ] ; then $(RM) $(BUILD_ROOT)/objects/$(PROJECT).sbr ; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).dll.manifest ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).dll.manifest ; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).exp ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).exp; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).ilk ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).ilk; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).pdb ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).pdb; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).lib ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).lib; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).dll ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).dll; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).map ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).map; fi ; if [ -f $(BUILD_ROOT)/lib/$(PROJECT).map.DEF ] ; then $(RM) $(BUILD_ROOT)/lib/$(PROJECT).map.DEF; fi ; if [ -f $(PROJECT).suo ] ; then $(RM) $(PROJECT).suo ; fi ; if [ -f $(PROJECT).ncb ] ; then $(RM) $(PROJECT).ncb ; fi
endif
endif
else
clobber: clean clobber_build
	@echo "*** Distribution PACKAGE=$(PACKAGE) clobbered."
endif

clobber_deplibs:
	$(SHOWCMD)$(SRC_ROOT)/build/oneach $(MAKE) clobber genfiles

clean_deplibs:
	$(SHOWCMD)$(SRC_ROOT)/build/oneach $(MAKE) clean

ifneq ($(SRC_ROOT),$(BUILD_ROOT))
nuke:
	@Nuke Tree
	@$(MV) $(BUILD_ROOT)/build /tmp/xxxx
	@$(RRM) $(BUILD_ROOT)
	@$(MAKE) init PLATFORM=$(PLATFORM) COMPILER=$(COMPILER) ARCH=$(ARCH) BUILD_TYPE=$(BUILD_TYPE)
	@$(MV) /tmp/xxxx/* $(BUILD_ROOT)/build

clobber_build:
	@echo ""; echo "*** Clobbering BUILD_ROOT=$(BUILD_ROOT) ***"
	@$(RRM) $(BUILD_ROOT)
else
	@$(ECHO) "SRC_ROOT == BUILD_ROOT: nuke/clobber_build is not allowed"
endif

genfiles: $(GENFILES)

ifneq ($(filter DISTRIBUTION_%,$(TYPE)),)
ifeq ($(DISTRIBUTION_BUILD_MODE),CLEAN)
pre_pre_init = clobber_build
endif
endif

pre_init: $(pre_pre_init)
ifeq ($(BUILD_TYPE),)
	$(error Invoke like: make init BUILD_TYPE=DEBUG -or- BUILD_TYPE=RELEASE)
endif
	@$(MKDIR) $(build_dirs)
	@echo "PLATFORM   := " $(PLATFORM) > $(build_makefile)
	@echo "COMPILER   := " $(COMPILER) >> $(build_makefile)
	@echo "ARCH       := " $(ARCH) >> $(build_makefile)
	@echo "BUILD_TYPE := " $(BUILD_TYPE) >> $(build_makefile)
ifneq ($(wildcard $(build_makefile_qt)),)
	@cat $(build_makefile_qt) >> $(build_makefile)
endif

init: pre_init
	@echo
	@echo "Building required binaries"
ifeq ($(PLATFORM),WINDOWS)
	$(MAKE) -C $(SRC_ROOT)/bin/misc/dll_export_all 
endif
	$(MAKE) -C $(SRC_ROOT)/pub/boost
	$(MAKE) -C $(SRC_ROOT)/pub/openssl
	$(MAKE) -C $(SRC_ROOT)/pub/ffmpeg
ifndef USE_QT5
	+$(MAKE) -C $(SRC_ROOT)/bin/apps/rvpkg rebuild
endif
	+$(MAKE) -C $(SRC_ROOT)/bin/imgtools/makeFBIOformats rebuild
	+$(MAKE) -C $(SRC_ROOT)/bin/imgtools/makeMovieIOformats rebuild
	@echo 
	@echo --- Finished Basic Initialization ---
	@echo You can edit: $(BUILD_ROOT)/build/Makefile.build
	@echo to customize the build. The build type is currently 
	@echo set to $(BUILD_TYPE)
	@echo " "


ifeq ($(TYPE),TEST)
run: $(target)
	$(target)

gdb: $(target)
	@$(ECHO) Running gdb $(target)
	gdb $(target) -fullname
endif


$(makefile_d): $(PROJECT_MAKEFILE)
	@+$(interdepend)


#
#  These define what the Xcode external build tool actions
#  are in terms of our make commands
#
ACTION_clean ?= clobber

rebuild:
	@+if [ ! -f $(build_makefile) ] ; then \
            $(MAKE) init ; \
            err=$$?; if [ $$err -ne 0 ]; then       \
            $(EXIT_ERR);                            \
            fi;                                     \
          fi
	@projPaths=`python $(MAKE_ROOT)/projectInfo -projectpaths`; err=$$?;  if [ $$err -ne 0 ]; then \
            echo "Error: encountered in projectInfo for 'rebuild' target";    \
            $(EXIT_ERR); \
            fi; \
            totalprojs=`echo $$projPaths | wc -w`; totalprojs=$$((totalprojs)) ; projnum=0; for name in $$projPaths ""; do \
	    if [ "$$name" != "" ]; then	                \
                projnum=$$((projnum+1));                  \
	        if [ "$(REBUILD_TARGET)" != "" ]; then	                \
	            echo "PROJECT #$$projnum/$$totalprojs: Entering $${name##*/} at `date` REBUILD_TARGET=$(REBUILD_TARGET)" ;    \
	        else \
	            echo "PROJECT #$$projnum/$$totalprojs: Entering $${name##*/} at `date`" ;    \
	        fi; \
	        $(MAKE) --no-print-directory -C $$name MAKEFLAGS="$(MAKEFLAGS)" $(REBUILD_TARGET) $(ACTION_$(ACTION)); \
                err=$$?; if [ $$err -ne 0 ]; then       \
                echo "Error: encountered in $$name($$projnum)... clobbering and remaking...";    \
	        $(MAKE) --no-print-directory -C $$name MAKEFLAGS="$(MAKEFLAGS)" clobber; \
	        $(MAKE) --no-print-directory -C $$name MAKEFLAGS="$(MAKEFLAGS)" $(REBUILD_TARGET) $(ACTION_$(ACTION)); \
                err=$$?; if [ $$err -ne 0 ]; then       \
                    echo "Error: encountered in $$name($$projnum)...";    \
                    errlist="$$errlist $$name($$projnum)";  \
                    $(EXIT_ERR);                            \
                    fi;                                     \
                fi;                                     \
	        echo ""; echo "***==================================***" ; echo ""; \
	    fi;                                         \
	done;                                           \
        if [ "$$errlist" != "" ]; then                  \
            echo ""; echo "Projects with errors:";      \
            echo          "=====================";      \
            for name in $$errlist; do                   \
                echo "$$name";                          \
            done;                                       \
            echo "";                                    \
        fi

deplibs:
	@$(makedeplibs)

modules:
	@$(makemodules)

showdylibs:
	@$(dybundlecmd)

$(qmakeproj):
	@$(makeqmake)

qmake: $(qmakeproj)

ifeq ($(PLATFORM),WINDOWS)
$(PROJECT).vcproj: $(qmakeproj)
	@$(QMAKE) -tp vc $(qmakeproj)
endif

ifeq ($(PLATFORM),DARWIN)
$(PROJECT).xcodeproj: $(qmakeproj)
	@$(QMAKE) -macx $(qmakeproj)

PHONY: xcode
xcode: $(PROJECT).xcodeproj
endif

.PHONY: rvpkgs rvpkgs2
rvpkgs:
ifdef mcmd
	+$(mcmd)
ifneq ($(rvpkg_targets),)
	$(BUILD_ROOT)/bin/rvpkg -force -install -add $(BUILD_ROOT)/plugins/ $(rvpkg_targets)
endif
else
	@echo
endif

rvpkgs2:
ifdef mcmd2
	+$(mcmd2)
ifneq ($(rvpkg_targets2),)
	$(BUILD_ROOT)/bin/rvpkg -force -add $(BUILD_ROOT)/plugins/ $(rvpkg_targets2)
endif
else
	@echo
endif

#
# Compounded targets
#
.PHONY: std-wrapper-rvpkgs2

std-wrapper-rvpkgs2:
	@+$(MAKE) --no-print-directory
ifdef WRAPPER
	@$(MAKE) --no-print-directory MAKEFLAGS= wrapper
endif
ifneq ($(filter NSAPPLICATION% EXECUTABLE%,$(TYPE)),)
	@$(MAKE) --no-print-directory MAKEFLAGS= rvpkgs2
endif


depends: $(depfiles)
	@echo Dependencies Created for $(PROJECT)

#
#  Texinfo and friends
#

debug:
	ddd $(target) `newestcoredump`

#
#   Emacs fly-make mode
#

.PHONY: check-syntax
check-syntax: 
ifeq ($(suffix $(CHK_SOURCES)),$(CXXSUFFIX))
	$(CXX_SYNTAX_RULE) $(CHK_SOURCES) 
endif
ifeq ($(suffix $(CHK_SOURCES)),$(CSUFFIX))
	$(CC_SYNTAX_RULE) $(CHK_SOURCES) 
endif
	@echo


#
#  Install rules
#
.PHONY: install_project_headers install_project_source
ifneq ($(INSTALL_HEADERS_ROOT),)
# we hv to filter for lower case src roots because gcc is generating
# lowercase paths in the .d files. This was seen under the windows VM but
# not a windows machine.
ifeq ($(PLATFORM),WINDOWS)
LOWERCASE_SRC_ROOT := $(call tolower,$(SRC_ROOT))
else
LOWERCASE_SRC_ROOT := $(SRC_ROOT)
endif

# 
# NB: Must filter out anything headers related to boost; since
#     Its exported separately and has its own tree structure.
#
install_project_headers:
	@echo "Installing project '$(PROJECT)' headers in $(INSTALL_HEADERS_ROOT)." 
	@for name in $(filter $(LOWERCASE_SRC_ROOT)/%$(HSUFFIX) $(SRC_ROOT)/%$(HSUFFIX) $(LOWERCASE_SRC_ROOT)/%$(HPPSUFFIX) $(SRC_ROOT)/%$(HPPSUFFIX), $(filter-out $(SRC_ROOT)/pub/boost/%, $^)) ""; do				\
	    if [ "$$name" != "" ]; then					\
		srcname=`basename $$name`;				\
		srcdir=`dirname $$name`;			\
		srcdir=`basename $$srcdir`;			\
		if [ -f $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname ]; then			\
		    diff $$name $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname > /dev/null;	\
		    diffval=$$?;					\
		fi;							\
		if [ ! -f $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname -o 			\
		      "x$$diffval" != "x0" ]; then			\
                    if [ ! -f $$name ]; then                         \
                        echo "*** Error: Missing file $$name";       \
                        exit 1;                                         \
                    fi;                                                 \
		    mkdir -p $(INSTALL_HEADERS_ROOT)/$$srcdir; cp -f $$name $(INSTALL_HEADERS_ROOT)/$$srcdir; \
                fi;                                                     \
	    fi;								\
	 done;
	@for name in $(filter-out /%, $(filter %$(HSUFFIX) %$(HPPSUFFIX),$^)) ""; do				\
	    if [ "$$name" != "" ]; then					\
		srcname=$$name;				\
		srcdir=$(PROJECT);			\
		if [ -f $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname ]; then			\
		    diff $$name $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname > /dev/null;	\
		    diffval=$$?;					\
		fi;							\
		if [ ! -f $(INSTALL_HEADERS_ROOT)/$$srcdir/$$srcname -o 			\
		      "x$$diffval" != "x0" ]; then			\
                    if [ ! -f $$name ]; then                         \
                        echo "*** Error: Missing file $$name";       \
                        exit 1;                                         \
                    fi;                                                 \
		    mkdir -p $(INSTALL_HEADERS_ROOT)/$$srcdir; cp -f $$name $(INSTALL_HEADERS_ROOT)/$$srcdir; \
		fi;							\
	    fi;								\
	 done;
	@for name in $^ ""; do	\
	    if [ "$$name" != "" ]; then					\
                if [ -d $$name ]; then			\
	            mkdir -p $(INSTALL_HEADERS_ROOT); cp -fR $$name $(INSTALL_HEADERS_ROOT); \
	        fi;							\
	    fi;								\
	 done;
endif


#----------------------------------------------------------------------
#
#	Rules for communicating with emacs python and people
#	Note: its really important that the project_info rule be fast to
#	output its data. In a big source tree, an interdepednancy tool
#	will spend a lot of time talking to Makefiles to get their
#	info. Something to keep in mind.
#

.PHONY: handshake target_info project_info configure_info files_info metasrc_info

handshake:
	@$(ECHO) its a pleasure meeting you

kind_info:
ifdef PACKAGE
	@$(ECHO) PACKAGE
endif
ifdef PROJECT
	@$(ECHO) PROJECT
endif

target_info:
	@$(ECHO) $(target)

files_info:
	@$(ECHO) cfiles $(cfiles);		\
	$(ECHO) mfiles $(mfiles);		\
	$(ECHO) cxxfiles $(cxxfiles);		\
	$(ECHO) sfiles $(sfiles);		\
	$(ECHO) yasmfiles $(yasmfiles);		\
	$(ECHO) MXXFILES $(mxxfiles);           \
	$(ECHO) uifiles $(uifiles);             \
	$(ECHO) yaccfiles $(yaccfiles);         \
	$(ECHO) lexfiles $(lexfiles);


metasrc_info:
	@$(ECHO) metasrcs $(metasrcs)

project_info:
	@$(ECHO) PROJECT $(PROJECT);		\
	$(ECHO) TYPE $(TYPE);			\
	$(ECHO) TARGET $(target);		\
	$(ECHO) OBJDIR $(obj_dir);		\
	$(ECHO) PROJECTPATHS $(projpaths);	\
	$(ECHO) LIBS $(LIBS);			\
	$(ECHO) SYSTEM_LIBS $(SYSTEM_LIBS);	\
	$(ECHO) SOURCE_LIBS $(sourcelibs);	\
	$(ECHO) MODULES $(MODULES);		\
	$(ECHO) MODULEPATHS $(modpaths);	\
	$(ECHO) RVPKGPATHS $(rvpkgpaths);	\
	$(ECHO) FRAMEWORKS $(frameworks);	\
	$(ECHO) IPATH $(ipath);			\
	$(ECHO) LPATH $(lpath);			\
	$(ECHO) FPATH $(fpath);			\
	$(ECHO) SRCS $(srcs);			\
	$(ECHO) METASRCS $(metasrcs);		\
	$(ECHO) SCRIPTS_DIR $(scripts_dir);	\
	$(ECHO) EXPORTED $(export_h);		\
	$(ECHO) GENFILES $(GENFILES);		\
	$(ECHO) MOCGENFILES $(MOCGENFILES);	\
	$(ECHO) QRCGENFILES $(QRCGENFILES);	\
	$(ECHO) QTRESOURCES $(QTRESOURCES);	\
	$(ECHO) DEPFILES $(depfiles);		\
	$(ECHO) METADEPFILES $(metadepfiles);	\
	$(ECHO) EXISTINGLIBS $(afiles);		\
	$(ECHO) LINK_TYPE $(LINK_TYPE);		\
	$(ECHO) QT_TYPE $(QT_TYPE);	

configure_info:
	@$(ECHO) COMPILER $(COMPILER);		\
	$(ECHO) DEBUGGER $(DEBUGGER);		\
	$(ECHO) PLATFORM $(PLATFORM);		\
	$(ECHO) ARCH $(ARCH);			\
	$(ECHO) SRC_ROOT $(SRC_ROOT);		\
	$(ECHO) BUILD_ROOT $(BUILD_ROOT);	\
	$(ECHO) MAKE_ROOT $(MAKE_ROOT);		\
	$(ECHO) CVSROOT $(CVSROOT);		\
	$(ECHO) CVSREAD $(origin CVSREAD);

flag_info:
	@$(ECHO) CFLAGS $(CFLAGS);		\
	$(ECHO) CXXFLAGS $(CXXFLAGS);		\
	$(ECHO) MCCFLAGS $(MCCFLAGS);		\
	$(ECHO) MXXFLAGS $(MXXFLAGS);		\
	$(ECHO) SHAREFLAGS $(SHAREFLAGS);	\
	$(ECHO) LDFLAGS $(LDFLAGS);		\
	$(ECHO) YFLAGS $(YFLAGS);		\
	$(ECHO) LFLAGS $(LFLAGS);

rules_info:
	@$(ECHO) CXX $(CXX_OBJ_RULE)
	@$(ECHO) MXX $(MXX_OBJ_RULE)
	@$(ECHO) CC $(CC_OBJ_RULE)
	@$(ECHO) MCC $(MCC_OBJ_RULE)

ldlibs:
	@$(ECHO) $(libs)

help:
	$(PAGER) $(SRC_ROOT)/build/DESCRIPTION

showdag:
	@echo ""
	@echo "============================================="
	@$(MAKE_ROOT)/showdag -cull

showdag_nocull: 
	@echo ""
	@echo "============================================="
	@$(MAKE_ROOT)/showdag

showdag_text: 
	@echo ""
	@echo "============================================="
	@$(MAKE_ROOT)/dag2dot -cull


MAKEFILE_MASTER_INCLUDED := TRUE

