
  Copyright (c) 2001, Tweak Films
  Copyright (c) 2008, Tweak Software
 
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

     * Redistributions of source code must retain the above
       copyright notice, this list of conditions and the following
       disclaimer.

     * Redistributions in binary form must reproduce the above
       copyright notice, this list of conditions and the following
       disclaimer in the documentation and/or other materials
       provided with the distribution.

     * Neither the name of the Tweak Software nor the names of its
       contributors may be used to endorse or promote products
       derived from this software without specific prior written
       permission.
 
  THIS SOFTWARE IS PROVIDED BY Tweak Software ''AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL Tweak Software BE LIABLE FOR
  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.


TWEAK BUILD SYSTEM

    The idea behind this is that you keep the source tree completely
    separated form the build tree. The location of the build and source
    trees are defined in environement variables (BUILD_ROOT and
    SRC_ROOT). This makes it easier to have multiple builds that differ
    slightly; in practice the difference is usually in the compiler
    flags. Most of the configuration is in the build system master
    Makefiles but some can be in the build tree.

    GNU make and python are required. On windows this means using cygwin. 

    See LICENSE file for terms of use

PLATFORM/COMPILER DEPENDENCE

    There are six variables which need to be set for the system to work
    properly:

            SRC_ROOT    location of src hierarchy
            BUILD_ROOT  location where products go
	    PLATFORM	os you're using (DARWIN, LINUX, WINDOWS)
	    ARCH	the CPU type (IA32, PPC32, IA64_32, PPC64)
	    COMPILER	the compiler you're using (GCC, VC8, XLC)
            BUILD_TYPE  one of DEBUG or RELEASE

    NOTE: COMPILER for GCC may be more specific: GCC4, GCC3, GCC2_96, etc
    on DARWIN it should just be GCC or CLANG.

    In some cases you don't actually have to set PLATFORM, ARCH, and
    COMPILER since they may only be needed when initializing a new
    BUILD_ROOT. But some project Makefiles may conditionally compile based
    on these values, so they may have to live in the environment in those
    cases.

    Typically, these values will be set as environment variables as in:

            setenv SRC_ROOT /path/to/src
            setenv BUILD_ROOT /path/to/build_stage
	    setenv PLATFORM LINUX
	    setenv ARCH IA32
	    setenv COMPILER GCC

USAGE

    The following documents commands you invoke from the shell while using
    the build system. Since this system relies on python scripts in
    addition to makefiles, you will want to put $SRC_ROOT/build into your
    path. Note that if you have multiple source trees, you should adjust
    your path accordingly.

    make
    make default

	Build the project and any sub-projects which do not yet exist. If
	sub-projects (projects on which the current one depends) are new
	than the current project, relink the current project. For example:
	if I have a foo EXECUTABLE project which dependent on a bar LIBRARY
	project and I rebuild bar, foo will want to relink (or rebuild)
	itself. If bar does not yet exist, running "make" in foo will
	automatically build bar. However, if you simple touch a header or
	source  file in bar, "make" in foo will not cause a rebuild of
	bar. For that you should use "make deplibs"

    make deplibs

	Build all projects (in the proper order) on which the current
	project depends. Do this unconditionally. Also does the equivalent
	of 'make modules'

    make relink

        Force a relink of the target binary if it is one.

    make modules

	Build all projects named in the local Makefile's MODULES variable
	if it exists. This variable is usually used by binaries which have
	plug-ins.

    make clean

	Remove all object and target files generated by the current project
	in the build tree. This does not remove dependency (.d) files nor
	does it remove the objects/project directory.

    make clobber

	Completely remove all products created by the current project from
	the build tree as well as all targets.
	
    make nuke

	Remove all products in the build tree. This will leave only your
	original $BUILD_ROOT/build/Makefile.build. Note that if for some
	reason the template makefile for your platform and compiler no
	longer exists, you will need to make init from scratch.

    make update_build

	Update the Makefile.build file in $BUILD_ROOT from the template
	file. The old version is copied to a backup file in the same
	directory. 

    make info|htm|pdf|doc

	This will make .info/.html/.pdf files from the $TEXINFO files and put the
	.info files into $BUILD_ROOT/{info,html,pdf}

    make showlinklibs

	Show a list of the dynamic libraries the target is linking againt

    run [:COMMAND] [ARGS ...]

	run is a python program which locates the project binary in the
	build tree (if it exists) and executes it with its arguments. If
	:COMMAND is given, it runs the program $BUILD_ROOT/bin/COMMAND with
	the given arguments.

    debug [COMMAND] [DEBUGGER_FLAGS]

	runs the debugger on the default target or on COMMAND with optional
	DEBUGGER_FLAGS

    oneach COMMAND [ARGS ...]

	run the command COMMAND passing it ARGS on each project on which
	the current project is dependant in build order. For example, you
	might do this:

	    oneach make clobber
	    make

	To completely rebuild a project and all its sub-projects. 

    makeDeplibs

	Normally this python program is invoked by "make deplibs". However,
	you can invoke it manually as well.

    makeDependsCygwin

	Used to set paths on cygwin on Windows to compile Windows native
	code. 

    makeInterdepend

	This is a python program used internally to generate the Makefile.d
	dependancy file. This file contains interdependancy
	information. You don't normally run this from manually.
    
    copyTargets

	Uses ldd on linux and otool on Mac to find all dependancies and
	package them up. (.so files, .dylibs, etc)


PROJECT MAKEFILE

    This Makefile supports build of EXECUTABLE, EXECUTABLE_WITH_PLUGINS,
    LIBRARY, SHARED_LIBRARY, NSAPPLICATION, and PLUGIN targets.

    Here's an example LIBRARY Makefile:

            PROJECT    = FooBar
            TYPE       = LIBRARY
  
            CXXFILES   = Foo Bar
            LIBS       = Baz

            include $(SRC_ROOT)/build/Makefile.master

    NOTE: Don't use := unless you really know what you're doing. Use +=
    when setting flags (CXXFLAGS += -Dfoo) not =.

    PROJECT indicates the name of the project that make is creating. There
    are rules about projects which determine where objects are deposited,
    where the final target is deposited, etc. The PROJECT name is used as a
    basename for many of these locations. For TEST makefiles, its possible
    to indicate an existing project as the PROJECT name -- the objects for
    the test will be deposited in a sub-directory of the PROJECT object
    directory in that case.

    TYPE is one of LIBRARY, EXECUTABLE, EXECUTABLE_WITH_PLUGINS,
    SHARED_LIBRARY, PLUGIN, MAYA_PLUGIN, ZIP_PACKAGE, or
    NSAPPLICATION. This variable must be present and determines the type of
    the target. (Why not use the suffix?  not all targets have suffixes).

    SCRIPTS has any associated scripts. SCRIPT_DIR is the target relative
    to BUILD_ROOT. SCRIPT_DIR is automatically set by depending on the
    TYPE, but can be overriden

    CXXFILES (also CFILES, MXXFILES, and MFILES). These variables tell Make
    the source files that will be compiled. You should not provide the
    suffixes for these files. The suffix is determined by the variable
    CXXSUFFIX (or CSUFFIX, MXXSUFFIX, and MSUFFIX). So in this case Make
    will compile for Foo.cc and Bar.cc. MFILES and MXXFILES refer to
    Objective C and Objective C++ files respectively.

    CXXFILES_PLATFORM, MXXFILES_PLATFORM, MFILES_PLATFORM, CFILES_PLATFORM
    variables can be used if some source files only apply to
    PLATFORM. These are added to the standard FILES variables above
    conditionally. 

    CXXFLAGS_PLATFORM, MXXFLAGS_PLATFORM, MFLAGS_PLATFORM, CFLAGS_PLATFORM,
    MDFLAGS_PLATFORM can be used to specifically change flags for a given
    platform. 

    LIBS should contain the names of libraries (without an extension or
    prefix) in link order. For example, to link against libm.a and
    libstdc++.a you would put "m stdc++" in that order. If you are linking
    against or including other project Makefiles, you include them here as
    well -- in link order. You can specify what type of linkage and other
    parameters here as well. For example, if you want to force
    dynamic/static linking:

                   LIBS = $(LD_STATIC) foo bar $(LD_DYNAMIC) baz

    This will force the linker to use static libs for foo and bar and
    a dynamic library for baz. NOTE: You must not use ":=" for assignment
    to LIBS, you have to use "=".

    LIBS_PLATFORM where PLATFORM is the defined platform in Makefile.build
    allows you to optionally add libs exclusively for a specific target in
    the same way that CXXFILES_PLATFORM adds source files for a given
    PLATFORM. 

    MODULES can be set to related projects. For example, a binary that does
    image viewing might have plugins for various image types. For
    convenience you can specify the plugin projects here. "make modules"
    will build them.

    QTFILES can be set to the name of files that must be run through moc
    (The Qt code generator). You don't need to include them in CXXFLAGS if
    you use QTFILES.

    IPATH in some circumstances, you may want to explicitly include a path
    to some header files. If so put the path(s) to the header file(s) in
    this variable without the "-I" prefix.

    LPATH in some circumstances you may need to link against libs in
    non-system and non-build directories. This variable should contain the
    paths to those libraries without the "-L" prefix.

    Finally, you must include the Makefile.master file which is found
    through the variable $(SRC_ROOT). 

MORE MAKEFILE VARIABLES

    PLUGIN_DIR determines where the target for PLUGIN goes. By default,
    this is $BUILD_ROOT/plugins. You can change this. For example, you
    could do this:

	  PLUGIN_DIR = prman/shadeops

    which would put the target in $BUILD_ROOT/prman/shadeops.

    AUXFILES are extra source files associated with the target. AUX_DIR
    determines where AUXFILES are copied after the build completes. AUX_DIR
    is created in the $BUILD_ROOT. 

THE BUILD_ROOT (STAGING AREA):

    The build system creates a directory hierarchy into which it puts
    objects and final profucts at $BUILD_ROOT. In order to start using the
    BUILD_ROOT you need initialize it like this (for example):

       make init COMPILER=GCC3 PLATFORM=DARWIN ARCH=PPC32 BUILD_TYPE=DEBUG
               
    You can also have the variables COMPILER, PLATFORM, and ARCH set as
    environment variables in which case you do not need to pass them to
    init. When you initialize a BUILD_ROOT area, a template platform
    specific Makefile will be copied to $BUILD_ROOT/build/Makefile.build
    you can edit this file to make changes that affect only the tree being
    built in BUILD_ROOT. For example, you may want to change the
    optimization level set by this file (usually defaults to debug).

    The directory hierarchy is (currently):

        $BUILD_ROOT/
            build/
                Makefile.build
            bin/
                foo*
            lib/
                foo.so
                bar.a
                ...
            include/
                FooProject/
                    foo.h
                    foo2.h
                BarProject/
                    bar.h
            objects/
                FooProject/
                    Makefile.d
                    foo.d
                    foo.o
                    foo2.d
                    foo2.o
                    ...
                BarProject/
                    Makefile.d
                    bar.d
                    bar.o
                    test/
                        bartest.o
                        test*
            plugins/
		maya/
		    foobar_plug.so
	    scripts/
		mel/
		    foobar.mel
            
    Header files (the ones in PUBLIC) are copied from the src tree to the
    build tree when make completes building a project directory. Put header
    files that must be shipped with binaries into the PUBLIC variable.

IMPLEMENTATION NOTES

    I've tried to use the guidlines in the GNU make info for Makefile
    writing. Some of the key more appearant features are:

        * The dependancies are per file (.d files) instead of a big
          Makefile.dep or something similar. This results in a simpler
          Makefile.master as well as removes some serious chicken and
          egg problems.

        * This Makefile uses GNU Make features such as scanning the
          make goal arguments to prevent clean and friends from trying
          to build the dependancies all the time.

        * External variables -- those that come from other Makefiles
          or from the environment are capitalized. Those that are
          purely internal to the Makefile are lower case.

